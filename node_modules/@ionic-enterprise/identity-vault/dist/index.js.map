{"version":3,"file":"index.js","sources":["../src/definitions.ts","../../../node_modules/tslib/tslib.es6.js","../src/BrowserVault.ts","../src/Vault.ts","../src/Device.ts","../src/vault-user.ts","../src/VaultMigrator.ts"],"sourcesContent":["/**\n * The meaning of the error code in the thrown {@link VaultError}.\n */\nexport enum VaultErrorCodes {\n  /**\n   * An unknown error happened.\n   * @constant `0`\n   */\n  Unknown,\n  /**\n   * The operation failed because the vault was locked.\n   * @constant `1`\n   */\n  VaultLocked,\n  /**\n   * The operation failed because the vault was unavailable.\n   * The most likely cause of this error is that a vault has not been configured.\n   * @constant `2`\n   */\n  VaultUnavailable,\n  /**\n   * The operation failed because the some of the vault provided arguments were invalid.\n   * @constant `3`\n   */\n  InvalidArguments,\n  /**\n   * The credentials were invalidated. This can happen when a user changes biometrics or passcode.\n   * @constant `4`\n   */\n  InvalidatedCredential,\n  /**\n   * Biometric security is unavailable due to a passcode not being set up at the system level.\n   * In order to use biometric identification on the device a system level passcode must be set up by the user.\n   * @constant `5`\n   */\n  SecurityNotAvailable,\n  /**\n   * User authentication failed.\n   * @constant `6`\n   */\n  AuthFailed,\n  /**\n   * Too many failed authentication attempts made against the custom passcode vault, so the vault was cleared and user will need to login again.\n   * @constant `7`\n   */\n  TooManyFailedAttempts,\n  /**\n   * The user cancelled the native authentication dialog.  \n   * \n   * **Note**: On iOS, this error code will also be thrown in the event that the native authentication dialog fails as a result of too many failed attempts.\n   * The user will be forced to cancel the dialog, triggering this error code.  \n   * \n   * On Android, this error also will be thrown if using {@link DeviceSecurityType.SystemPasscode} or {@link DeviceSecurityType.Both} in the event of too many failed attempts.  \n   * Its currently not possible to get the nature of failures from the native authentication dialog, and similar to iOS, the user will be forced to cancel the dialog, triggering this error code.\n   * @constant `8`\n   */\n  UserCanceledInteraction,\n  /**\n   * The user provided mismatched passcodes.\n   * @constant `9`\n   */\n  MismatchedPasscode,\n  /**\n   * The operation requires passcode to be setup but it isn't set yet. Call {@link Vault.setCustomPasscode} to set it.\n   * @constant `10`\n   */\n  MissingPasscode,\n  /**\n   * The operation failed because the application tried to unlock the vault with passcode authentication,\n   * but the vault is not configured to allow passcode authentication.\n   * @constant `11`\n   */\n  PasscodeNotEnabled,\n  /**\n   * The key was not found. This can happen when a user changes biometrics or passcode.\n   * @constant `12`\n   */\n  KeyNotFound,\n  /**\n   * The operation failed because biometric authentication is not enabled.\n   * This can occur when biometrics is not supported by the device\n   * or when biometrics has not been configured for the device or vault.\n   * @constant `13`\n   */\n  BiometricsNotEnabled,\n  /**\n   * @ignore\n   */\n  InvalidAuthMode,\n  /**\n   * Biometrics have not been authed yet (Android only)\n   * @constant `15`\n   */\n  MissingBiometrics,\n  /**\n   * {@link DeviceSecurityType.SystemPasscode} for {@link DeviceSecurityType} not available on this Android device.\n   * @constant `16`\n   */\n  AndroidSystemPasscodeUnavailable,\n  /**\n   * Biometrics have been locked out, usually because of too many failed attempts.\n   * \n   * **Note:** This error will never be thrown if using {@link DeviceSecurityType.SystemPasscode} or {@link DeviceSecurityType.Both}.\n   * Its currently not possible to get the nature of failures from the native authentication dialog, so the only error that would be thrown is {@link VaultErrorCodes.UserCanceledInteraction} as the user \n   * is forced to cancel the prompt.\n   * \n   * @constant `17`\n   */\n  AndroidBiometricsLockedOut,\n  /**\n   * Biometrics have been locked out, usually because of too many failed attempts.\n   * \n   * @constant `18`\n   */\n  iOSBiometricsLockedOut,\n  /**\n   * An unexpected error has occurred in the Android keystore.\n   * \n   * @constant `19`\n   */\n  AndroidUnexpectedKeystoreError\n}\n\n/**\n * An error that can be thrown by the plugin.\n *\n * @example\n * try {\n *  vault.unlock();\n * } catch(e) {\n *   switch (e.code) {\n *     case VaultErrorCodes.AuthFailed:\n *       alert('You failed to authenticate!');\n *       break;\n *     case VaultErrorCodes.UserCanceledInteraction:\n *       alert('You cancelled the face id prompt!');\n *       break;\n *     default:\n *       throw e;\n *   }\n * }\n */\nexport interface VaultError {\n  /**\n   * - Type: `string`\n   * \n   * A text description of the error that occurred.\n   */\n  message: string;\n  /**\n   * - Type: {@link VaultErrorCodes}\n   * \n   * The error code enum representing the error.\n   */\n  code: VaultErrorCodes;\n}\n\n/**\n * The possible values returned by {@link Device.getAvailableHardware}\n */\nexport enum SupportedBiometricType {\n  /** The device supports fingerprint scanning. */\n  Fingerprint = \"fingerprint\",\n  /** The device supports facial recognition. */\n  Face = \"face\",\n  /** The device supports iris scanning. */\n  Iris = \"iris\"\n}\n\n/**\n * Possible device biometric strength levels on Android (always `strong` on iOS).\n * [More Information](https://source.android.com/security/biometric/measure#tiered-authentication).\n */\nexport enum BiometricSecurityStrength {\n  /** Refers to Class 2 - Weak biometric security */\n  Weak = \"weak\",\n  /** Refers to Class 3 - Strong biometric security */\n  Strong = \"strong\"\n}\n\n/**\n * When type is set to 'DeviceSecurity', determines which aspects of the device to use to secure the vault.\n * Note: Android only supports `SystemPasscode` on Android 11 and greater.\n * @default `Both`\n */\nexport enum DeviceSecurityType {\n  /** Will allow a system passcode to secure the vault. On Android, only supported on Android 11 and greater. */\n  SystemPasscode = \"SystemPasscode\",\n  /** WIll allow biometric hardware tos secure the vault. */\n  Biometrics = \"Biometrics\",\n  /** WIll allow both SystemPasscode or Biometrics as an option to secure the vault. */\n  Both = \"Both\",\n  /** No biometric security option will be used. */\n  None = \"None\",\n}\n\n/**\n * The type of vault\n */\nexport enum VaultType {\n  /** No additional security is required in the app as long as the device was unlocked with a secure method. */\n  SecureStorage = \"SecureStorage\",\n  /** Uses additional device features to add an additional layer of security while the user is in the app. */\n  DeviceSecurity = \"DeviceSecurity\",\n  /** User will set a custom passcode that will be used to access the vault. */\n  CustomPasscode = \"CustomPasscode\",\n  /** Data will persist only while the application is in memory. */\n  InMemory = \"InMemory\",\n}\n\n/**\n * For Android, when type is {@link VaultType.DeviceSecurity} and deviceSecurityType is {@link DeviceSecurityType.Both}, this options specifies if you want to\n * prefer a Strong Cryptographic Vault or the System Passcode fallback when they both aren't available.\n * @default `StrongVault`\n */\nexport enum AndroidBiometricCryptoPreference {\n  /** Prefer to use a strong cryptographic vault. */\n  StrongVault = \"StrongVault\",\n  /** Prefer the system passcode fallback. */\n  SystemPasscode = \"SystemPasscode\"\n}\n\n// OLD METHODS\n\n/**\n * The type of authentication the vault should be configured to allow.\n * @deprecated For use in legacy Vault Migrator only.\n * @ignore\n */\n export enum AuthMode {\n  /**\n   * Biometrics authentication should only be allowed\n   */\n  BiometricOnly,\n\n  /**\n   * Passcode authentication should only be allowed\n   */\n  PasscodeOnly,\n\n  /**\n   * Both biometric and passcode authentication should be allowed\n   */\n  BiometricAndPasscode,\n\n  /**\n   * Both biometric and passcode authentication should be disabled.\n   * With this setting all data in the vault will be cleared on lock or\n   * if the app is closed. Stored data is kept only in memory.\n   */\n  InMemoryOnly,\n\n  /**\n   * Use biometrics if it is available, otherwise use passcode\n   */\n  BiometricOrPasscode,\n\n  /**\n   * Both biometric and passcode authentication will be disabled but any stored values\n   * will persist and be stored securely at rest using the keychain and will be available\n   * without needing to authenticate via passcode or biometrics when the device is unlocked.\n   */\n  SecureStorage,\n}\n\n/**\n * The interface for the Default Session.\n * Extend this interface to make a custom session\n *\n * @example\n * MyCustomSession extends DefaultSession {\n *   email: string;\n *   age: number;\n *   nicknames: string[];\n * }\n *\n * @ignore\n */\n export interface DefaultSession {\n  username: string;\n  token: string;\n}\n\n/**\n * The possible values returned by {@link getBiometricType}\n * @property `touchID` | `faceID` | `none`\n * @ignore\n */\nexport type BiometricType = \"touchID\" | \"faceID\" | \"none\";\n\n/**\n * An interface that describes the vault. In {@link IdentityVaultUser} this\n * defaults to `_lastUser` & `default` you can optionally add this to the constructor\n * to accomplish advanced use cases multi-tenant vaults.\n *\n * @deprecated For use in legacy Vault Migrator only.\n * @ignore\n */\nexport interface VaultDescriptor {\n  /**\n   * The username for the vault you wish to access\n   */\n  username: string;\n\n  /**\n   * The vaultId for the vault you wish to access\n   */\n  vaultId: string;\n}\n\n/**\n * The configuration returned from {@link IonicNativeAuthPlugin} when {@link getConfig} is called.\n *\n * @ignore\n */\nexport interface PluginConfiguration {\n  /**\n   * The values the uniquely identify the vault\n   */\n  descriptor: VaultDescriptor;\n\n  /**\n   * Whether biometric authentication is enabled for the vault\n   */\n  isBiometricsEnabled: boolean;\n\n  /**\n   * Whether passcode authentication is enabled for the vault\n   */\n  isPasscodeEnabled: boolean;\n\n  /**\n   * Whether {@link AuthMode.SecureStorage} is enabled for the vault\n   */\n  isSecureStorageModeEnabled: boolean;\n\n  /**\n   * Whether a passcode needs to be set with {@link setPasscode}\n   */\n  isPasscodeSetupNeeded: boolean;\n\n  /**\n   * Obscures the app when backgrounded to avoid leaking sensitive information, such as financial statements or balances.\n   * App screenshots won't work on Android 10 devices using gesture navigation if this option is set to true.\n   */\n  hideScreenOnBackground: boolean;\n\n  /**\n   * The amount of number of milliseconds the app can be in the background for until the vault locks\n   */\n  lockAfter: number;\n}\n\n/**\n * @hidden\n * @deprecated For use in legacy Vault Migrator only.\n * @ignore\n */\nexport interface VaultOptionsBase {\n  /**\n   * The {@link AuthMode} to configure a new vault with. Note: This will only\n   * affect newly created vaults. Vaults with existing data and configuration will use\n   * there previous configuration. They can be change by unlocking and then chaning the AuthMode.\n   *\n   * @default - {@link BiometricAndPasscode}\n   *\n   */\n  authMode?: AuthMode;\n\n  /**\n   * The amount of number of milliseconds the app can be in the background for until the vault locks.\n   * A value of 0 means the vault won't lock in the background.\n   * @default 0\n   */\n  lockAfter?: number;\n\n  /**\n   * Obscures the app when backgrounded to avoid leaking sensitive information, such as financial statements or balances.\n   * App screenshots won't work on Android 10 devices using gesture navigation if this option is set to true.\n   * @default false\n   */\n  hideScreenOnBackground?: boolean;\n\n  /**\n   * After too many failed authentication attempts, should the vault be cleared?\n   * @default true\n   */\n  shouldClearVaultAfterTooManyFailedAttempts?: boolean;\n\n  /**\n   * If biometric auth fails, allow system pin fallback.\n   * @default false\n   */\n  allowSystemPinFallback?: boolean;\n\n  /**\n   * The title text for the Android authentication prompt.\n   * @default \"Please Authenticate\"\n   */\n  androidPromptTitle?: string;\n\n  /**\n   * The subtitle text for the Android authentication prompt.\n   * @default null\n   */\n  androidPromptSubtitle?: string;\n\n  /**\n   * The description text for the Android authentication prompt.\n   * @default null\n   */\n  androidPromptDescription?: string;\n\n  /**\n   * The cancel text for the Android authentication prompt.\n   * @default \"Cancel\"\n   */\n  androidPromptNegativeButtonText?: string;\n\n  /**\n   * For iOS, the prompt text for the biometric prompt\n   * @default \"Authenticate to log in\"\n   */\n  iosPromptText?: string;\n}\n\n/**\n * The options passed in to initialize the vault.\n *\n * @deprecated For use in legacy Vault Migrator only.\n * @ignore\n */\nexport interface VaultOptions extends VaultOptionsBase {\n  /**\n   * Whether or not to attempt to automatically restore the session when the vault is ready\n   * If {@link restoreSessionOnReady} and {@link unlockOnAccess} are\n   * both true the vault will be immediately unlocked & the session restored if onReady if the\n   * vault is in use.\n   * @default false\n   */\n  restoreSessionOnReady?: boolean;\n\n  /**\n   * Whether or not to attempt to automatically unlock the vault when a value is accessed.\n   * If {@link restoreSessionOnReady} and {@link unlockOnAccess} are\n   * both true the vault will be immediately unlocked & the session restored if onReady if the\n   * vault is in use.\n   * @default false\n   */\n  unlockOnAccess?: boolean;\n\n  /**\n   * Whether or not to attempt to automatically unlock the vault when the vault is ready\n   * @default false\n   */\n  unlockOnReady?: boolean;\n}\n\n/**\n * The configuration file returned to event handlers such as\n * {@link onConfigChange} and {@link onVaultReady}.\n * @ignore\n */\nexport interface VaultConfig extends VaultOptionsBase {\n  /**\n   * Whether a passcode needs to be set with {@link setPasscode}\n   */\n  isPasscodeSetupNeeded: boolean;\n}\n\n/**\n * The options passed the the {@link IonicNativeAuthPlugin} when creating a vault with {@link getVault}\n * @ignore\n */\nexport interface PluginOptions extends VaultDescriptor {\n  /**\n   * The amount of number of milliseconds the app can be in the background for until the vault locks\n   */\n  lockAfter?: number;\n\n  /**\n   * Obscures the app when backgrounded to avoid leaking sensitive information, such as financial statements or balances.\n   * App screenshots won't work on Android 10 devices using gesture navigation if this option is set to true.\n   */\n  hideScreenOnBackground?: boolean;\n\n  /**\n   * After too many failed authentication attempts, should the vault be cleared?\n   * @default true\n   */\n  shouldClearVaultAfterTooManyFailedAttempts?: boolean;\n\n  /**\n   * If biometric auth fails, allow system pin fallback.\n   *\n   * Please note: when Android devices are set to allow system pin fallback, the behavior of the biometrics prompt changes.\n   * The OS biometric prompt will not report that biometrics failed nor that the user has been locked out of biometrics.\n   * It is only currently possible to know the user either canceled the authentication prompt, or was successful in verifying.\n   *\n   * @default false\n   */\n  allowSystemPinFallback?: boolean;\n\n  /**\n   * The title text for the Android authentication prompt.\n   * @default \"Please Authenticate\"\n   */\n  androidPromptTitle?: string;\n\n  /**\n   * The subtitle text for the Android authentication prompt.\n   * @default null\n   */\n  androidPromptSubtitle?: string;\n\n  /**\n   * The description text for the Android authentication prompt.\n   * @default null\n   */\n  androidPromptDescription?: string;\n\n  /**\n   * The cancel text for the Android authentication prompt.\n   * @default \"Cancel\"\n   */\n  androidPromptNegativeButtonText?: string;\n\n  /**\n   * For iOS, the localized explanation for authentication shown in the dialog presented to the user.\n   * @default \"Authenticate to log in\"\n   */\n  iosPromptText?: string;\n\n  /**\n   * A handler that will receive events any time the vault is locked\n   */\n  onLock?(event: LockEvent): any;\n\n  /**\n   * A handler that will receive events any time the vault is unlocked\n   */\n  onUnlock?(event: PluginConfiguration): any;\n\n  /**\n   * A handler that will receive events any time the vault is configuration is changed\n   */\n  onConfig?(event: PluginConfiguration): any;\n\n  /**\n   * Called when there is an error during vault setup\n   *\n   * @param error - The {@link VaultError} that occurred.\n   *\n   */\n  onError?(error: VaultError): any;\n\n  /**\n   * Called when the vault is configured and available.\n   *\n   * @param vault - The {@link IdentityVault}  instance.\n   *\n   */\n  onReady?(vault: IdentityVault): any;\n}\n\n/**\n * The underlying vault API. You can gain direct access to the vault for more advanced usage by\n * using the {@link getVault IdentityVaultUser.getVault} method.\n * @ignore\n */\nexport interface IdentityVault {\n  /**\n   * The current configuration of the vault will stay current as long as {@link unsubscribe} is not called.\n   */\n  config?: PluginConfiguration;\n\n  /**\n   * Unsubscribe the instance from events about the vault.\n   *\n   * @example\n   * vault.unsubscribe();\n   *\n   */\n  unsubscribe(): Promise<void>;\n\n  /**\n   * Clear all vault data including stored tokens, values, and passcodes. The vault will be empty and unlocked after this.\n   *\n   * @example\n   * vault.clear()\n   */\n  clear(): Promise<void>;\n\n  /**\n   * Lock the vault clearing the contents from memory and requiring biometrics or passcode to unlock\n   *\n   * @example\n   * vault.lock()\n   */\n  lock(): Promise<void>;\n\n  /**\n   * Check whether the vault is currently locked\n   *\n   * @example\n   * if(!(await vault.isLocked())) {\n   *     // Do something if vault is not locked\n   * }\n   *\n   * @returns whether the vault is locked\n   */\n  isLocked(): Promise<boolean>;\n\n  /**\n   * Check whether the biometrics are locked on the device\n   *\n   * @example\n   * const bioLockedOut = await vault.isLockedOutOfBiometrics();\n   *\n   * @returns whether biometrics are locked\n   */\n  isLockedOutOfBiometrics(): Promise<boolean>;\n\n  /**\n   * Check whether the vault has any values stored in it.\n   *\n   * @example\n   * const vaultIsInUse = await vault.isInUse();\n   *\n   * @returns whether the vault has stored values\n   */\n  isInUse(): Promise<boolean>;\n\n  /**\n   * Get the current configuration of the vault\n   *\n   * @example\n   * const config = await vault.getConfig();\n   *\n   * @returns the configuration\n   */\n  getConfig(): Promise<PluginConfiguration>;\n\n  /**\n   * Check how many remaining failed attempts are left until vault clears\n   *\n   * @example\n   * const remainingAttempts = await vault.remainingAttempts();\n   *\n   * @returns the number of remaining attempts\n   */\n  remainingAttempts(): Promise<number>;\n\n  /**\n   * Get the username associated with the vault\n   *\n   * @example\n   * const username = await vault.getUsername();\n   *\n   * @returns the username for the vault\n   */\n  getUsername(): Promise<string>;\n\n  /**\n   * Store a value securely in the token slot. This is equivalent to calling {@link storeValue storeValue(\"token\", token)}.\n   *\n   * @example\n   * vault.storeToken(token);\n   *\n   * @param token - the value to store in the token slot\n   *\n   * @throws {@link VaultError} - if vault is locked, or if passcode is enabled but passcode has not been setup\n   */\n  storeToken(token: any): Promise<void>;\n\n  /**\n   * Get any data stored in the token slot. This is equivalent to calling {@link getValue getValue(\"token\")}.\n   *\n   * @example\n   * const token = await vault.getToken();\n   *\n   * @returns token data\n   *\n   * @throws {@link VaultError} - if vault is locked\n   */\n  getToken(): Promise<any>;\n\n  /**\n   * Store data securely under the given key.\n   *\n   * @example\n   * vault.storeValue(\"email\", emailToken);\n   *\n   * @param key - the key to store in the value in\n   * @param value - the value to store\n   *\n   * @throws {@link VaultError} - if vault is locked, or if passcode is enabled but passcode has not been setup\n   */\n  storeValue(key: string, value: any): Promise<void>;\n\n  /**\n   * Removes data under the given key.\n   *\n   * @example\n   * vault.removeValue(\"email\");\n   *\n   * @param key - the key to remove the value from\n   *\n   * @throws {@link VaultError} - if vault is locked, or if passcode is enabled but passcode has not been setup\n   */\n  removeValue(key: string): Promise<void>;\n\n  /**\n   * Get a value stored under the given key.\n   *\n   * @param key - the key where the value is stored\n   *\n   * @returns the value stored at the key\n   *\n   * @throws {@link VaultError} - if vault is locked\n   */\n  getValue(key: string): Promise<any>;\n\n  /**\n   * Get all keys with stored values.\n   *\n   * @example\n   * const keys = await vault.getKeys();\n   *\n   * @returns array with all keys\n   *\n   * @throws {@link VaultError} - if vault is locked\n   */\n  getKeys(): Promise<string[]>;\n\n  /**\n   * Get the type of biometrics the device supports\n   *\n   * @example\n   * const biometricType = await vault.getBiometricType();\n   *\n   * @deprecated this method has been deprecated in favor of {@link getAvailableHardware}\n   *\n   * @returns the type of biometrics the device supports\n   */\n  getBiometricType(): Promise<BiometricType>;\n\n  /**\n   * Gets the types of biometrics the device supports.\n   *\n   * Please note, this method only shows the biometrics the device is capable of, and does\n   * not reflect whether the biometric methods are enrolled or enabled.\n   *\n   * Traditionally Android has only supported fingerprint biometrics through the SDK. As of\n   * Android 10 multiple options are supported. Samsung devices can offer iris and face\n   * biometrics that exists outside the scope of the Android SDK. Since there is no official\n   * Android SDK support to detect those Samsung features, we attempt to determine their\n   * presence based on if the device has the Samsung face or iris biometrics software installed.\n   *\n   * @example\n   * const availableHardware = await vault.getAvailableHardware();\n   *\n   * @returns the list of biometrics the device supports\n   */\n  getAvailableHardware(): Promise<SupportedBiometricType[]>;\n\n  /**\n   * Enable/Disable Biometric authentication for the vault\n   *\n   * @example\n   * vault.setBiometricsEnabled(true);\n   *\n   * @param isBiometricsEnabled - whether or not biometrics should be enabled\n   *\n   * @throws {@link VaultError} - if biometrics is unavailable or the vault is locked\n   */\n  setBiometricsEnabled(isBiometricsEnabled: boolean): Promise<void>;\n\n  /**\n   * Set whether or not the screen will be obscured in app switcher mode\n   * @param enabled\n   * @returns void\n   */\n  setHideScreenOnBackground(enabled: boolean): Promise<void>;\n\n  /**\n   * Check whether or not biometrics is enabled on the vault\n   *\n   * @example\n   * const biometricsEnabled = await vault.isBiometricsEnabled();\n   *\n   * @returns whether or not biometrics is enabled\n   */\n  isBiometricsEnabled(): Promise<boolean>;\n\n  /**\n   * Check whether or not biometrics is supported by the device\n   * and has been configured by the current user of the device\n   *\n   * @example\n   * const biometricsAvailable = await vault.isBiometricsAvailable();\n   *\n   * @returns whether or not biometrics is available\n   */\n  isBiometricsAvailable(): Promise<boolean>;\n\n  /**\n   * Check whether or not biometrics is supported by the device\n   *\n   * @example\n   * const biometricsSupported = await vault.isBiometricsSupported();\n   *\n   * @returns whether or not biometrics is supported\n   */\n  isBiometricsSupported(): Promise<boolean>;\n\n  /**\n   * Check whether or not a passcode needs to be set for the vault using {@link setPasscode}\n   *\n   * @example\n   * const passcodeSetupNeeded = await vault.isPasscodeSetupNeeded();\n   *\n   * @returns whether or not the passcode needs to be set\n   */\n  isPasscodeSetupNeeded(): Promise<boolean>;\n\n  /**\n   * Set or Change the passcode for the vault\n   *\n   * @example\n   * vault.setPasscode();\n   *\n   * @param passcode - The passcode to set. If left null a native dialog will prompt the user to enter it.\n   *\n   * @throws {@link VaultError} - if the vault is locked, passcode is disabled, user canceled pin prompt, or pin was mismatched\n   */\n  setPasscode(passcode?: string): Promise<void>;\n\n  /**\n   * Check if passcode authentication is enabled for the vault\n   *\n   * @example\n   * const passcodeEnabled = await vault.isPasscodeEnabled();\n   *\n   * @returns whether or not the passcode is enabled\n   */\n  isPasscodeEnabled(): Promise<boolean>;\n\n  /**\n   * Enable/Disable passcode authentication for the vault\n   *\n   * @example\n   * vault.setPasscodeEnabled(true);\n   *\n   * @param isPasscodeEnabled - whether or not passcode should be enabled\n   *\n   * @throws {@link VaultError} - if the vault is locked\n   */\n  setPasscodeEnabled(isPasscodeEnabled: boolean): Promise<void>;\n\n  /**\n   * Check if {@link AuthMode.SecureStorage} is enabled for the vault\n   *\n   * @example\n   * const secureStorageModeEnabled = await vault.isSecureStorageModeEnabled();\n   *\n   * @returns whether or not the secure storage mode is enabled\n   */\n  isSecureStorageModeEnabled(): Promise<boolean>;\n\n  /**\n   * Enable/Disable secure storage mode for the vault. Setting {@link AuthMode.SecureStorage} automatically disables passcode\n   * and biometric authentication and allows for session values to be stored persistently and securely at rest using the keychain but allowing the user\n   * to access the data without authenticating as long as the device is unlocked.\n   *\n   * @example\n   * vault.setSecureStorageModeEnabled(true);\n   *\n   * @param isSecureStorageModeEnabled - whether or not secure storage mode should be enabled\n   *\n   * @throws {@link VaultError} - if the vault is locked\n   */\n  setSecureStorageModeEnabled(\n    isSecureStorageModeEnabled: boolean\n  ): Promise<void>;\n\n  /**\n   * Unlock the vault using either passcode or biometrics\n   *\n   * @example\n   * vault.unlock();\n   *\n   * @param usingPasscode - whether or not to use passcode to unlock the vault\n   * @param passcode - The passcode to use. If left null a native dialog will prompt the user to enter it.\n   *\n   * @throws {@link VaultError} - if the vault is locked, the unlock type wasn't enabled, user canceled pin prompt, or pin was mismatched\n   */\n  unlock(usingPasscode?: boolean, passcode?: string): Promise<void>;\n}\n\n/**\n * The lock event passed to the {@link onVaultLocked} handler.\n * @ignore\n */\nexport interface LockEvent {\n  /**\n   * If the data was persisted to the device before lock\n   */\n  saved: boolean;\n  /**\n   * If the lock was due to a background timeout\n   */\n  timeout: boolean;\n}\n\n/**\n * The main class which you can extend in order to implement vault usage.\n *  @typeparam `T` must extend {@link DefaultSession}\n *\n * @usage\n * ```typescript\n * interface MyCustomSession extends DefaultSession {\n *   // username & token are inherited\n *   email: string;\n *   age: number;\n *   nicknames: string[];\n * }\n *\n * export class IdentityService extends IonicIdentityVaultUser<MyCustomSession> {\n *\n * constructor(private http: HttpClient, private router: Router, platform: Platform) {\n *   super(platform, {\n *     authMode: AuthMode.BiometricAndPasscode,\n *     restoreSessionOnReady: false,\n *     unlockOnReady: false, // set true to auto prompt the user to unlock when vault is ready\n *     unlockOnAccess: true,\n *     lockAfter: 5000, // lock after 5 seconds in the background\n *     hideScreenOnBackground: true\n *   });\n *\n *   onVaultUnlocked(config: VaultConfig) {\n *     //Route to my home page\n *   }\n *\n *   onVaultLocked(event: LockEvent) {\n *     //Route to my login page\n *   }\n *\n * }\n * ```\n * @ignore\n */\nexport interface IdentityVaultUser<T extends {} = DefaultSession> {\n  /**\n   * Get raw access to the underlying vault api\n   */\n  getVault(): Promise<IdentityVault>;\n\n  /**\n   * The stored session data\n   */\n  getSession(): Promise<T | undefined>;\n\n  /**\n   * Called when the vault has been locked\n   * @param event - The data about the lock event {@link LockEvent}\n   */\n  onVaultLocked(event: LockEvent): any;\n\n  /**\n   * Called when the vault has been unlocked\n   *\n   * @param config - The current configuration {@link VaultConfig} of the vault\n   */\n  onVaultUnlocked(state: VaultConfig): any;\n\n  /**\n   * Called when there has been a configuration change in the vault\n   *\n   * @param config - The updated configuration {@link VaultConfig} of the vault\n   */\n  onConfigChange(state: VaultConfig): any;\n\n  /**\n   * Called when the vault is ready\n   *\n   * @param config - The current configuration {@link VaultConfig} of the vault\n   *\n   * @returns - A promise that resolves when the vault is successfully configured and available.\n   */\n  onVaultReady(state: VaultConfig): any;\n\n  /**\n   * Called when there is an error during vault setup\n   *\n   * @param error - The {@link VaultError} that occurred.\n   *\n   */\n  onSetupError(error: VaultError): any;\n\n  /**\n   * Called when the session object is restored.\n   *\n   * @param session - The {@link DefaultSession} or user defined session that occurred.\n   *\n   */\n  onSessionRestored(session: T): any;\n\n  /**\n   * Called when the session fails to auto restore\n   *\n   * @param err - The {@link VaultError} or that occurred.\n   *\n   */\n  onSessionRestoreError(err: VaultError): any;\n\n  /**\n   * Called when the automatically unlocking the vault after it is ready fails.\n   *\n   * @param err - The {@link VaultError} or that occurred.\n   *\n   */\n  onUnlockOnReadyError(err: VaultError): any;\n\n  /**\n   * Called when attempting passcode unlock to allow for user defined passcode prompts.\n   *\n   * @param isPasscodeSetRequest - Whether or not this is a request to set the passcode.\n   *\n   * @returns - a string to use as the passcode of undefined to use native prompts\n   *\n   */\n  onPasscodeRequest(isPasscodeSetRequest: boolean): Promise<string | void>;\n\n  /**\n   * Promise ensuring the user vault is ready to be accessed or denoting an error in setup;\n   *\n   * @returns - A promise that resolves when the vault is succesfully configured and available.\n   */\n  ready(): Promise<void>;\n\n  /**\n   * Get the type of biometrics the device supports\n   *\n   * @returns the type of biometrics the device supports\n   */\n  getBiometricType(): Promise<BiometricType>;\n\n  /**\n   * Set the {@link AuthMode} for the vault. The vault must be unlocked or this will throw an error.\n   *\n   * @param authMode - The {@link AuthMode} to use.\n   *\n   * @throws {@link VaultError} - If the vault is locked or the mode is unavailale due to device hardware\n   */\n  setAuthMode(authMode: AuthMode): Promise<void>;\n\n  /**\n   * Get the {@link AuthMode} for the vault.\n   */\n  getAuthMode(): Promise<AuthMode>;\n\n  /**\n   * Returns the underlying Plugin Implementation. This can be overriden in the sub class\n   * service to allow for a customer browser implementation. Note that when overriding this\n   * with a browser implementation you should use the storeValue/getValue functions with the key\n   * `session` to store & retrieve the session as described or by {@link DefaultSession} or the interface\n   * that extends it.\n   *\n   * @usage\n   * ```typescript\n   * getPlugin(): IonicNativeAuthPlugin {\n   *   if (this.platform.is('cordova')) {\n   *     return super.getPlugin();\n   *   }\n   *   // MyCustomerBrowserImplementation must implement the IonicNativeAuthPlugin interface\n   *   // make sure getValue('session') & storeValue('session') store & retrieve the session.\n   *   return MyCustomBrowserImplementation();\n   * }\n   * ```\n   */\n  getPlugin(): IonicNativeAuthPlugin;\n\n  /**\n   * Lock the user out without clearing their secure session\n   * information from the vault\n   */\n  lockOut(): Promise<void>;\n\n  /**\n   * Unlock the user's vault using the AuthMode configured for the vault\n   * or the override passed in to the call.\n   * This will call the {@link onPasscodeRequest} handler\n   * if the specified {@link AuthMode} allows for it to allow for user defined passcode prompt\n   * You can get more fine grain contol using the {@link IdentityVault} directly\n   * by calling {@link getVault}\n   */\n  unlock(authMode?: AuthMode): Promise<void>;\n\n  /**\n   * Log the user out entirely, and forget any stored\n   * authentication tokens\n   */\n  logout(): Promise<void>;\n\n  /**\n   * Check if there are any saved sessions in the vault\n   */\n  hasStoredSession(): Promise<boolean>;\n\n  /**\n   * Get the session from memory (without checking the vault for it)\n   */\n  getSession(): Promise<T | undefined>;\n\n  /**\n   * Restore the session from the vault\n   */\n  restoreSession(): Promise<T | undefined>;\n\n  /**\n   * Store the session to the vault\n   * @param session - the session to store\n   */\n  saveSession(session: T): Promise<void>;\n\n  /**\n   * Login a new session for the user. This method will clear the vault & any stored PIN for\n   * previously stored sessions.\n   *\n   * @param session - the session to store\n   * @param authMode? - optionally specify the {@link AuthMode} to  use for the new session.\n   * Defaults to the current configuration for the vault if undefined.\n   *\n   */\n  login(session: T, authMode?: AuthMode): Promise<void>;\n\n  /**\n   * Enable/Disable Biometric authentication\n   *\n   * @param isBiometricsEnabled - whether or not biometrics should be enabled\n   *\n   * @throws {@link VaultError} - if biometrics is unavailable or the vault is locked\n   */\n  setBiometricsEnabled(isBiometricsEnabled: boolean): Promise<void>;\n\n  /**\n   * Set whether or not the screen will be obscured in app switcher mode\n   * @param enabled\n   * @returns void\n   */\n  setHideScreenOnBackground(enabled: boolean): Promise<void>;\n\n  /**\n   * Enable/Disable passcode authentication. This will cause {@link setPasscode}\n   * to fire if passcode setup is required causing\n   * the {@link onPasscodeRequest} handler to fire\n   * to allow for user defined passcode prompt.\n   * You can get more fine grain contol using the {@link IdentityVault} directly\n   * by calling {@link getVault}\n   *\n   * @param isPasscodeEnabled - whether or not passcode should be enabled\n   *\n   * @throws {@link VaultError} - if the vault is locked\n   */\n  setPasscodeEnabled(isPasscodeEnabled: boolean): Promise<void>;\n\n  /**\n   * Set or change the passcode for the user\n   * This will call the {@link onPasscodeRequest} handler\n   * to allow for user defined passcode prompt.\n   * You can get more fine grain contol using the {@link IdentityVault} directly\n   * by calling {@link getVault}\n   *\n   * @throws {@link VaultError} - if the vault is locked, passcode is disabled, user canceled pin prompt, or pin was mismatched\n   */\n  setPasscode(): Promise<void>;\n\n  /**\n   * Check whether or not biometrics is enabled on the vault\n   *\n   * @returns whether or not biometrics is enabled\n   */\n  isBiometricsEnabled(): Promise<boolean>;\n\n  /**\n   * Check whether or not biometrics is supported by the device\n   * and has been configured by the current user of the device\n   *\n   * @returns whether or not biometrics is available\n   */\n  isBiometricsAvailable(): Promise<boolean>;\n\n  /**\n   * Check whether or not biometrics is supported by the device\n   *\n   * @returns whether or not biometrics is supported\n   */\n  isBiometricsSupported(): Promise<boolean>;\n\n  /**\n   * Check if passcode authentication is enabled for the vault\n   *\n   * @returns whether or not the passcode is enabled\n   */\n  isPasscodeEnabled(): Promise<boolean>;\n\n  /**\n   * Check if {@link AuthMode.SecureStorage} is enabled for the vault\n   *\n   * @returns whether or not the secure storage mode is enabled\n   */\n  isSecureStorageModeEnabled(): Promise<boolean>;\n}\n\n/**\n * The native plugin\n * @ignore\n */\nexport interface IonicNativeAuthPlugin {\n  getVault(config: PluginOptions): IdentityVault;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { VaultError, VaultErrorCodes } from \"./definitions\";\nimport { IdentityVaultConfig } from \"./IdentityVaultConfig\";\nimport { VaultInterface } from \"./VaultInterface\";\n\ntype Callback<T = any> = (value: T) => void;\ntype EmptyCallback = () => void;\nconst STORAGE_KEYS = {\n  DATA: \"data\",\n};\n\n/**\n * THIS VAULT DOES NOT IMPLEMENT SECURE STORAGE IN THE BROWSER. It only exists\n * as a way to run browser-compatible code in place of Identity Vault. Browsers\n * do not have a secure storage element same as native devices. This class\n * is intended to be used to enable running your application in the browser while\n * simulating the functions of Identity Vault using sessionStorage.\n *\n * Represents a vault implementation for browser compatibility.\n */\nexport class BrowserVault implements VaultInterface {\n  /** @ignore */\n  private isVaultLocked: boolean = false;\n\n  /** @ignore */\n  private configCallback: Callback<IdentityVaultConfig> | undefined;\n\n  /** @ignore */\n  private errorCallback: Callback<VaultError> | undefined;\n\n  /** @ignore */\n  private lockCallback: EmptyCallback | undefined;\n\n  /** @ignore */\n  private unlockCallback: EmptyCallback | undefined;\n\n  /** @ignore */\n  config: IdentityVaultConfig;\n\n  /**\n   * @usage\n   * ```typescript\n   * const vault = new Vault({\n   *  key: 'com.company.myvaultapp',\n   *  type: 'CustomPasscode',\n   *  deviceSecurityType: 'Both',\n   *  lockAfterBackgrounded: 2000,\n   * });\n   * ```\n   * @param config\n   */\n  constructor(config: IdentityVaultConfig) {\n    console.warn(\n      \"THIS VAULT DOES NOT IMPLEMENT SECURE STORAGE IN THE BROWSER AND IS NOT INTENDED FOR PRODUCTION USE. It only exists as a way to run browser-compatible code in place of Identity Vault. Browsers do not have a secure storage element same as native devices. This class is intended to be used to enable running your application in the browser while simulating the functions of Identity Vault using sessionStorage.\"\n    );\n    this.config = Object.assign(\n      {\n        deviceSecurityType: \"Both\",\n        androidBiometricsPreferStrongVaultOrSystemPasscode: \"StrongVault\",\n        shouldClearVaultAfterTooManyFailedAttempts: false,\n        customPasscodeInvalidUnlockAttempts: 5,\n        unlockVaultOnLoad: false,\n      },\n      config\n    );\n    this.isVaultLocked = config.unlockVaultOnLoad ? false : true;\n  }\n\n  /** See {@link Vault.doesVaultExist} */\n  doesVaultExist(): Promise<boolean> {\n    const data = this.getDataObj();\n    return Promise.resolve(!!data);\n  }\n\n  /** See {@link Vault.clear} */\n  clear(): Promise<void> {\n    this.unlockIfLocked();\n    sessionStorage.removeItem(this.getKey(STORAGE_KEYS.DATA));\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.exportVault} */\n  exportVault(): Promise<Record<string, string>> {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    return Promise.resolve(data ?? {});\n  }\n\n  /** See {@link Vault.importVault} */\n  importVault(data: Record<string, string>): Promise<void> {\n    this.setDataObj(data);\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.isLocked} */\n  isLocked(): Promise<boolean> {\n    return Promise.resolve(this.isVaultLocked);\n  }\n\n  /** See {@link Vault.getKeys} */\n  getKeys(): Promise<string[]> {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    if (!data) return Promise.resolve([]);\n    return Promise.resolve(Object.keys(data));\n  }\n\n  /** See {@link Vault.getValue} */\n  getValue<T = any>(key: string): Promise<T | null> {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    return Promise.resolve(data?.[key] ?? null);\n  }\n\n  /** See {@link Vault.lock} */\n  lock(): Promise<void> {\n    this.lockCallback?.();\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.removeValue} */\n  removeValue(key: string): Promise<void> {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    if (!data) return Promise.resolve();\n    const { [key]: removed, ...dataAfterRemoval } = data;\n    this.setDataObj(dataAfterRemoval);\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.setCustomPasscode} */\n  setCustomPasscode(passcode: string): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.setValue} */\n  setValue<T = any>(key: string, value: T): Promise<void> {\n    this.unlockIfLocked();\n    const data = this.getDataObj();\n    if (!data) {\n      this.setDataObj({ [key]: value });\n    } else {\n      this.setDataObj({ ...data, [key]: value });\n    }\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.onConfigChanged} */\n  onConfigChanged(callback: Callback<IdentityVaultConfig>): void {\n    this.configCallback = callback;\n  }\n\n  /** See {@link Vault.onError} */\n  onError(callback: Callback<VaultError>): void {\n    this.errorCallback = callback;\n  }\n\n  /** See {@link Vault.onLock} */\n  onLock(callback: EmptyCallback): void {\n    this.lockCallback = callback;\n  }\n\n  /** See {@link Vault.onPasscodeRequested} */\n  onPasscodeRequested(callback: Callback<boolean>): void {\n    // No passcode support\n  }\n\n  /** See {@link Vault.onUnlock} */\n  onUnlock(callback: EmptyCallback): void {\n    this.unlockCallback = callback;\n  }\n\n  /** See {@link Vault.unlock} */\n  unlock(): Promise<void> {\n    this.unlockCallback?.();\n    return Promise.resolve();\n  }\n\n  /** See {@link Vault.updateConfig} */\n  updateConfig(config: IdentityVaultConfig): Promise<void> {\n    this.config = config;\n    this.configCallback?.(config);\n    return Promise.resolve();\n  }\n\n  /** @ignore */\n  requestBiometricPrompt(): Promise<boolean> {\n    this.unlockIfLocked();\n    return Promise.resolve(true);\n  }\n\n  /** @ignore */\n  private unlockIfLocked(): void {\n    if (this.isVaultLocked) {\n      this.unlock();\n    }\n  }\n\n  /** @ignore */\n  private getDataObj(): Record<string, any> | null {\n    const value = sessionStorage.getItem(this.getKey(STORAGE_KEYS.DATA));\n    if (!value) return null;\n    try {\n      return JSON.parse(value);\n    } catch (e) {\n      this.errorCallback?.({\n        message: \"Unable to parse data store\",\n        code: VaultErrorCodes.Unknown,\n      });\n      return null;\n    }\n  }\n\n  /** @ignore */\n  private setDataObj(data: Record<string, any>): void {\n    try {\n      const dataStr = JSON.stringify(data);\n      sessionStorage.setItem(this.getKey(STORAGE_KEYS.DATA), dataStr);\n    } catch (e) {\n      this.errorCallback?.({\n        message: \"Unable to serialize data\",\n        code: VaultErrorCodes.Unknown,\n      });\n    }\n  }\n\n  /** @ignore */\n  private getKey(key: string): string {\n    return `IV-${this.config.key}-${key}`;\n  }\n}\n","import {\n  AndroidBiometricCryptoPreference,\n  DeviceSecurityType,\n  VaultError,\n  VaultErrorCodes,\n  VaultType,\n} from \"./definitions\";\nimport { IdentityVaultConfig } from \"./IdentityVaultConfig\";\nimport { VaultInterface } from \"./VaultInterface\";\n\n/**\n * Represents a vault for secure value storage\n */\nexport class Vault implements VaultInterface {\n  /** @ignore */\n  private passCodeRequestedCallback?: (\n    isPasscodeSetRequest: boolean\n  ) => Promise<void>;\n\n  /** @ignore */\n  private defaultConfig = {\n    deviceSecurityType: DeviceSecurityType.None,\n    androidBiometricsPreferStrongVaultOrSystemPasscode:\n      AndroidBiometricCryptoPreference.StrongVault,\n    shouldClearVaultAfterTooManyFailedAttempts: false,\n    customPasscodeInvalidUnlockAttempts: 5,\n    unlockVaultOnLoad: false,\n  };\n\n  /** @ignore */\n  config: IdentityVaultConfig;\n\n  /**\n   * @usage\n   * ```typescript\n   * const vault = new Vault({\n   *  key: 'com.company.myvaultapp',\n   *  type: 'CustomPasscode',\n   *  deviceSecurityType: DeviceSecurityType.None,\n   *  lockAfterBackgrounded: 2000,\n   * });\n   * ```\n   * @param config\n   */\n  constructor(config: IdentityVaultConfig) {\n    // set defaults\n    this.config = Object.assign(this.defaultConfig, config);\n\n    // setting sane defaults\n    if (\n      config.deviceSecurityType === DeviceSecurityType.None &&\n      config.type === VaultType.DeviceSecurity\n    ) {\n      config.deviceSecurityType = DeviceSecurityType.Both;\n    }\n\n    this.resume = this.resume.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.setup().then(() => {\n      this.getPersistedVaultConfig();\n    });\n  }\n\n  /**\n   * Resolves true if a vault with the same key already exists, and false if not.\n   * The vault does not need to be unlocked to check.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const vaultExists = await vault.doesVaultExists()\n   * if (!vaultExists) {\n   *  // the vault does not exist...\n   * }\n   * ```\n   */\n  doesVaultExist(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.doesVaultExist());\n        },\n        \"VaultPlugin\",\n        \"doesVaultExist\",\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Clears out the current vault and removes it from the system.\n   * Note: The vault does not need to be unlocked in order to clear it. No credentials are checked\n   * when clearing the vault.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.clear();\n   * ```\n   */\n  clear(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve();\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.clear());\n        },\n        \"VaultPlugin\",\n        \"clear\",\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Exports the data of the current vault in its entirety.\n   * The data is a map with keys that are strings and values that are JSON.\n   * Calling `exportVault` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const data = await vault.exportVault();\n   * ```\n   *\n   * @return The resolved object is a map with string keys and string values.\n   *\n   */\n  exportVault(): Promise<{ [key: string]: string }> {\n    return new Promise<{ [key: string]: string }>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.exportVault());\n        },\n        \"VaultPlugin\",\n        \"exportVault\",\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Imports data into the vault, replacing the current contents of the vault.\n   * The data is a map with keys that are strings and values that are JSON.\n   * Calling `importVault` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const dataFromElsewhere = await getUserData();\n   * const newVault = new Vault(vaultConfig);\n   * await newVault.importVault(dataFromElsewhere);\n   * ```\n   *\n   * @param data The entire data object to be imported. The shape of data must be {[key: string]: string}.\n   *\n   */\n  importVault(data: { [key: string]: string }): Promise<void> {\n    const jsonData = JSON.stringify(data);\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        resolve,\n        (error) => {\n          this.handleError(resolve, reject, error, () =>\n            this.importVault(data)\n          );\n        },\n        \"VaultPlugin\",\n        \"importVault\",\n        [this.config, jsonData]\n      );\n    });\n  }\n\n  /**\n   * Checks if the vault is currently in a locked state, which signifies that the contents\n   * of the secure vault are not currently accessible. `isLocked` can also return true if the\n   * vault does not exist.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const locked = await vault.isLocked();\n   * if (locked) {\n   *  // vault is locked (or does not exist);\n   * }\n   * ```\n   */\n  isLocked(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        \"VaultPlugin\",\n        \"isLocked\",\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Returns an array of keys that are currently in the vault.\n   * Calling `getKeys` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const allKeys = await vault.getKeys();\n   * allKeys.forEach((key) => {\n   *  // do something with the key\n   * });\n   * ```\n   */\n  getKeys(): Promise<string[]> {\n    return new Promise<string[]>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.getKeys());\n        },\n        \"VaultPlugin\",\n        \"getKeys\",\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Gets the value for a given key. Returns null if the key does not exist.\n   * Calling `getValue` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const userFirstName = await vault.getValue<string>(\"firstname\");\n   * ```\n   *\n   * @param key The key to look up the value for\n   *\n   */\n  getValue<T = any>(key: string): Promise<T | null> {\n    return new Promise<T | null>((resolve, reject) => {\n      cordova.exec(\n        (data: string | null) => {\n          if (!data) {\n            // android returns null as an empty string, so manually convert it here\n            resolve(null);\n          } else {\n            try {\n              resolve(JSON.parse(data));\n            } catch (err) {\n              resolve(data as any);\n            }            \n          }\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.getValue(key));\n        },\n        \"VaultPlugin\",\n        \"getValue\",\n        [this.config, key]\n      );\n    });\n  }\n\n  /**\n   * Locks the vault if it is currently unlocked.\n   * Locking the vault with remove all secure data from memory inside of Identity Vault, but not your application.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.lock();\n   * ```\n   */\n  lock(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve();\n        },\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        \"VaultPlugin\",\n        \"lock\",\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Removes a value from the vault.\n   * Calling `removeValue` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.removeValue(\"address\");\n   * ```\n   *\n   * @param key The key to remove\n   *\n   */\n  removeValue(key: string): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        resolve,\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.removeValue(key));\n        },\n        \"VaultPlugin\",\n        \"removeValue\",\n        [this.config, key]\n      );\n    });\n  }\n\n  /**\n   * When the vault type is set to 'CustomPasscode', this method sets the passcode required to\n   * secure the vault.\n   * This method is typically called in the `onPasscodeRequested` callback.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * const code = window.prompt(\"Enter your passcode.\");\n   * if (code) {\n   *  await vault.setCustomPasscode(code);\n   * }\n   * ```\n   *\n   * @param passcode The user supplied passcode to secure the vault with.\n   *\n   */\n  setCustomPasscode(passcode: string): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        resolve,\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        \"VaultPlugin\",\n        \"setCustomPasscode\",\n        [this.config, passcode]\n      );\n    });\n  }\n\n  /**\n   * Sets the value of an item in the vault.\n   * Calling `setValue` will attempt to unlock the vault if it is currently locked.\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.setValue<string>(\"theme\", theme);\n   * ```\n   *\n   * @param key The key for the new value.\n   * @param value The value to store in the vault. Value can be of any type, as it will be parsed to JSON in the vault.\n   *\n   */\n  setValue<T = any>(key: string, value: T): Promise<void> {\n    const jsonValue = JSON.stringify(value);\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        resolve,\n        (error) => {\n          this.handleError(resolve, reject, error, () =>\n            this.setValue(key, value)\n          );\n        },\n        \"VaultPlugin\",\n        \"setValue\",\n        [this.config, key, jsonValue]\n      );\n    });\n  }\n\n  /**\n   * Triggers when a config change occurs.\n   *\n   * @usage\n   * ```typescript\n   * vault.onConfigChanged((config) => {\n   *  console.log(\"updated config: \", config);\n   * });\n   * ```\n   * @param callback The callback function that will be called when the event triggers. Passes in the current vault config.\n   *\n   */\n  onConfigChanged(callback: (config: IdentityVaultConfig) => void) {\n    cordova.exec(\n      (data) => {\n        callback(JSON.parse(data));\n      },\n      (error) => console.error(error),\n      \"VaultPlugin\",\n      \"onConfigChanged\",\n      []\n    );\n  }\n\n  /**\n   * Triggers when an error occurs in the application.\n   * Errors that come back as rejected promises also trigger this event.\n   *\n   * @usage\n   * ```typescript\n   * vault.onError((err) => {\n   *  console.log('ERROR from callback', JSON.stringify(err));\n   * });\n   * ```\n   *\n   * @param callback The callback function that will be called when the event triggers. Passes in the error object.\n   *\n   */\n  onError(callback: (err: VaultError) => void) {\n    cordova.exec(() => {}, callback, \"VaultPlugin\", \"onError\", []);\n  }\n\n  /**\n   * Triggers when the vault enters a locked state.\n   *\n   * @usage\n   * ```typescript\n   * vault.onLock(() => { displayNotification(\"Vault locked.\"); })\n   * ```\n   *\n   * @param callback The callback function that will be called when the event triggers.\n   *\n   */\n  onLock(callback: () => void) {\n    cordova.exec(\n      callback,\n      (error) => console.error(error),\n      \"VaultPlugin\",\n      \"onLock\",\n      [this.config]\n    );\n  }\n\n  /**\n   * For CustomPasscode vaults, this event triggers when the vault is attempting to unlock\n   * and the passcode has not been set yet. The callback function will pass in a Promise that,\n   * when resolved, with attempt to unlock the vault again calling the same method that originally\n   * tried to unlock the vault. Before the promise is resolved, you should prompt the user to supply a passcode, and\n   * then supply that value to `setCustomPasscode`.\n   *\n   * @usage\n   * ```typescript\n   * vault.onPasscodeRequested(async (isPasscodeSetRequest) => {\n   *  const message = isPasscodeSetRequest\n   *    ? 'Setup Passcode' // passcode is being set for first time\n   *    : 'Enter passcode'; // passcode is being asked for unlock\n   *  const passcode = window.prompt(message) || '';\n   *   vault.setCustomPasscode(passcode);\n   *   return Promise.resolve();\n   * });\n   * ```\n   *\n   * @param callback The callback function that will be called when the event triggers. The function returns a promise with a boolean that indicates if the passcode is being setup for the first time for the vault or not.\n   *\n   */\n  onPasscodeRequested(\n    callback: (isPasscodeSetRequest: boolean) => Promise<void>\n  ) {\n    this.passCodeRequestedCallback = callback;\n  }\n\n  /**\n   * Triggers when the vault enters an unlocked state.\n   *\n   * @usage\n   * ```typescript\n   * vault.onUnlock(() => {\n   *  console.log(\"vault is now unlocked\");\n   * });\n   * ```\n   * @param callback The callback function that will be called when the event triggers.\n   *\n   */\n  onUnlock(callback: () => void) {\n    cordova.exec(\n      callback,\n      (error) => console.error(error),\n      \"VaultPlugin\",\n      \"onUnlock\",\n      [this.config]\n    );\n  }\n\n  /**\n   * Manually unlock the vault. Will trigger any authentication mechanism needed to access the vault (passcode, biometrics, etc..).\n   *\n   * @usage\n   * ```typescript\n   * const vault = new Vault(existingVaultConfig);\n   * await vault.unlock();\n   * ```\n   */\n  unlock(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        () => {\n          resolve();\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () => this.unlock());\n        },\n        \"VaultPlugin\",\n        \"unlock\",\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * Updates the configuration of the current vault.\n   *\n   *  @usage\n   * ```typescript\n   * async function changeVaultType(type: VaultType) {\n   *  const vault = new Vault(this.existingVaultConfig);\n   *  const newConfig = { ...this.existingVaultConfig, type };\n   *  await vault.updateConfig(newConfig);\n   *  this.existingVaultConfig = newConfig;\n   * }\n   * ```\n   *\n   * @param config The new config\n   *\n   */\n  updateConfig(config: IdentityVaultConfig): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      config = Object.assign(this.defaultConfig, config);\n\n      // setting sane defaults\n      if (\n        config.deviceSecurityType === DeviceSecurityType.None &&\n        config.type === VaultType.DeviceSecurity\n      ) {\n        config.deviceSecurityType = DeviceSecurityType.Both;\n      }\n\n      cordova.exec(\n        () => {\n          this.config = config;\n          resolve();\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () =>\n            this.updateConfig(config)\n          );\n        },\n        \"VaultPlugin\",\n        \"updateConfig\",\n        [config]\n      );\n    });\n  }\n\n  /** @ignore */\n  private async handleError(\n    resolve: (data: any) => void,\n    reject: (error: any) => void,\n    error: any,\n    retryFunc?: any\n  ) {\n    if (\n      error.code === VaultErrorCodes.MissingPasscode &&\n      this.passCodeRequestedCallback\n    ) {\n      await this.passCodeRequestedCallback(error.extra.isPasscodeSetRequest);\n      if (retryFunc) {\n        try {\n          const data = await retryFunc();\n          resolve(data);\n        } catch (e) {\n          reject(e);\n        }\n      }\n    } else if (error.code === VaultErrorCodes.MissingBiometrics) {\n      cordova.exec(\n        async () => {\n          const data = await retryFunc();\n          resolve(data);\n        },\n        (e) => reject(e),\n        \"VaultPlugin\",\n        \"requestBiometricPrompt\",\n        [this.config]\n      );\n    } else {\n      reject(error);\n    }\n  }\n\n  /** @ignore */\n  requestBiometricPrompt() {\n    return new Promise<boolean>((resolve, reject) => {\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          this.handleError(resolve, reject, error, () =>\n            this.requestBiometricPrompt()\n          );\n        },\n        \"VaultPlugin\",\n        \"requestBiometricPrompt\",\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * @ignore\n   */\n  private resume() {\n    const noop = () => {};\n    cordova.exec(\n      noop,\n      (error) => {\n        this.handleError(noop, noop, error, () => this.resume());\n      },\n      \"VaultPlugin\",\n      \"appResumed\",\n      [this.config]\n    );\n  }\n\n  /**\n   * @ignore\n   */\n  private setup() {\n    return new Promise((resolve, reject) => {\n      document.addEventListener(\"resume\", this.resume, false);\n      cordova.exec(\n        resolve,\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        \"VaultPlugin\",\n        \"setup\",\n        [this.config]\n      );\n    });\n  }\n\n  /**\n   * @ignore\n   */\n  private getPersistedVaultConfig() {\n    return new Promise<void>((resolve, reject) => {\n      cordova.exec(\n        (data: string | null) => {\n          if (!data) {\n            resolve();\n          } else {\n            const vaultConfig = JSON.parse(data) as IdentityVaultConfig;\n            this.config = Object.assign(this.config, vaultConfig);\n            resolve();\n          }\n        },\n        (error) => {\n          this.handleError(resolve, reject, error);\n        },\n        \"VaultPlugin\",\n        \"getVaultConfig\",\n        [this.config]\n      );\n    });\n  }\n}\n","import {\n  BiometricSecurityStrength,\n  SupportedBiometricType,\n} from \"./definitions\";\n\nexport class Device {\n  /** @ignore */\n\n  constructor() {}\n  /**\n   * Gets the types of biometrics the device supports.\n   *\n   * @usage\n   * ```typescript\n   * const hardware = await Device.getAvailableHardware();\n   * hardware.forEach((biometricType) => console.log(\"Type: \" + biometricType));\n   * ```\n   */\n  public static getAvailableHardware(): Promise<SupportedBiometricType[]> {\n    return new Promise<SupportedBiometricType[]>((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve([]);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          resolve(data);\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        \"DevicePlugin\",\n        \"getAvailableHardware\",\n        []\n      );\n    });\n  }\n\n  /**\n   * Check whether biometrics are locked out on the device.\n   * \n   * On Android, the locked out state will only known after an attempted biometric unlock.\n   *\n   * @usage\n   * ```typescript\n   * const isLockedOut = await Device.isLockedOutOfBiometrics();\n   * if (isLockedOut) {\n   *  // device is locked out ...\n   * }\n   * ```\n   */\n  public static isLockedOutOfBiometrics(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        \"DevicePlugin\",\n        \"isLockedOutOfBiometrics\",\n        []\n      );\n    });\n  }\n\n  /**\n   * Checks the device biometric strength level.\n   *\n   * On iOS this will always return 'strong'.\n   *\n   * @usage\n   * ```typescript\n   * const biometricStrength = await Device.getBiometricStrengthLevel();\n   * ```\n   */\n  public static getBiometricStrengthLevel(): Promise<BiometricSecurityStrength> {\n    return new Promise<BiometricSecurityStrength>((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(BiometricSecurityStrength.Weak);\n        return;\n      }\n      cordova.exec(\n        (data) => {\n          resolve(data);\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        \"DevicePlugin\",\n        \"getBiometricStrengthLevel\",\n        []\n      );\n    });\n  }\n\n  /**\n   * Check whether or not the screen will be obscured in app switcher mode.\n   *\n   * @usage\n   * ```typescript\n   * const willHideScreen = await Device.isHideScreenOnBackgroundEnabled();\n   * ```\n   */\n  public static isHideScreenOnBackgroundEnabled(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        \"DevicePlugin\",\n        \"isHideScreenOnBackgroundEnabled\",\n        []\n      );\n    });\n  }\n\n  /**\n   * Set whether or not the screen will be obscured in app switcher mode\n   *\n   * @usage\n   * ```typescript\n   * await Device.setHideScreenOnBackground(true);\n   * ```\n   */\n  public static setHideScreenOnBackground(enabled: boolean): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve();\n        return;\n      }\n      cordova.exec(\n        () => {\n          resolve();\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        \"DevicePlugin\",\n        \"setHideScreenOnBackground\",\n        [enabled]\n      );\n    });\n  }\n\n  /**\n   * Check whether the device OS-level passcode has been set.\n   *\n   * @usage\n   * ```typescript\n   * const hasSystemPasscode = await Device.isSystemPasscodeSet();\n   * if (hasSystemPasscode) {\n   *  // device has a system passcode\n   * }\n   * ```\n   */\n  public static isSystemPasscodeSet(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        \"DevicePlugin\",\n        \"isSystemPasscodeSet\",\n        []\n      );\n    });\n  }\n\n  /**\n   * Check whether or not biometrics is supported by the device and has been configured by the current user of the device.\n   *\n   * @usage\n   * ```typescript\n   * const biometricsEnabled = await Device.isBiometricsEnabled();\n   * if (!biometricsEnabled) {\n   *  // biometrics not enabled on this device...\n   * }\n   * ```\n   */\n  public static isBiometricsEnabled(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          console.log(\"biometrics is enabled: \", data);\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        \"DevicePlugin\",\n        \"isBiometricsEnabled\",\n        []\n      );\n    });\n  }\n\n  /**\n   * Check whether or not biometrics is supported by the device.\n   *\n   * @usage\n   * ```typescript\n   * const biometricsSupported = await Device.isBiometricsSupported();\n   * if (biometricsSupported) {\n   *   // biometrics is supported on this device...\n   * }\n   * ```\n   */\n  public static isBiometricsSupported(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        \"DevicePlugin\",\n        \"isBiometricsSupported\",\n        []\n      );\n    });\n  }\n\n  /**\n   * Check if the device has a secure hardware enclave.\n   * \n   * @usage\n   * ```typescript\n   * const hasSecureHardware = await Device.hasSecureHardware();\n   * if (!hasSecureHardware) {\n   *    // this device doesn't have secure hardware\n   * }\n   * ```\n   */\n  public static hasSecureHardware(): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      if (!(\"cordova\" in window)) {\n        resolve(false);\n        return;\n      }\n\n      cordova.exec(\n        (data) => {\n          resolve(JSON.parse(data));\n        },\n        (error) => {\n          Device.handleError(resolve, reject, error);\n        },\n        \"DevicePlugin\",\n        \"hasSecureHardware\",\n        []\n      );\n    });\n  }\n\n  /**\n   * @ignore\n   */\n  private static async handleError(\n    resolve: (data: any) => void,\n    reject: (error: any) => void,\n    error: any,\n    retryFunc?: any\n  ) {\n    reject(error);\n  }\n}\n","import {\n  DefaultSession,\n  IdentityVault,\n  IdentityVaultUser,\n  IonicNativeAuthPlugin,\n  VaultDescriptor,\n  VaultOptions,\n  PluginConfiguration,\n  LockEvent,\n  AuthMode,\n  VaultError,\n  VaultErrorCodes,\n  VaultConfig,\n  BiometricType,\n  SupportedBiometricType,\n} from './definitions';\n\ndeclare var IonicNativeAuth: IonicNativeAuthPlugin;\n\n/**\n * @hidden\n * \n * @ignore\n */\nexport class IonicIdentityVaultUser<T extends {} = DefaultSession> implements IdentityVaultUser<T> {\n  private vault!: IdentityVault;\n  private vIonicNativeAuth?: IonicNativeAuthPlugin;\n  private _readyPromise: Promise<any>;\n  private _config!: PluginConfiguration;\n  private _readyResolve!: (value?: void | PromiseLike<void>) => void;\n  private _readyReject!: (reason?: any) => void;\n  private _readyCalled: boolean = false;\n  private descriptor: VaultDescriptor;\n  private session?: T;\n\n  constructor(public platform: { ready: () => Promise<any> }, private readonly options: VaultOptions, descriptor?: VaultDescriptor) {\n    this.descriptor = descriptor || {username: '_lastUser', vaultId: 'default'};\n    this._readyPromise = this.initializeVault();\n  }\n\n  get token(): string | undefined {\n    const session: any = this.session;\n    return session && session.token;\n  }\n\n  get username():string | undefined {\n    const session: any = this.session;\n    return session && session.username;\n  }\n\n  get config(): VaultConfig {\n    if (!this._config) {\n      return undefined as any;\n    }\n    let authMode: AuthMode | undefined;\n    const bioEnabled = this._config.isBiometricsEnabled;\n    const passEnabled = this._config.isPasscodeEnabled;\n    const secureStorageMode = this._config.isSecureStorageModeEnabled;\n    if (secureStorageMode) {\n      authMode = AuthMode.SecureStorage;\n    } else if (bioEnabled && passEnabled){\n      authMode = AuthMode.BiometricAndPasscode;\n    } else if (bioEnabled && !passEnabled) {\n      authMode = AuthMode.BiometricOnly;\n    } else if (!bioEnabled && passEnabled) {\n      authMode = AuthMode.PasscodeOnly;\n    } else if (!bioEnabled && !passEnabled) {\n      authMode = AuthMode.InMemoryOnly;\n    }\n    return {\n      authMode: authMode,\n      isPasscodeSetupNeeded: this._config.isPasscodeSetupNeeded,\n      lockAfter: this._config.lockAfter,\n      hideScreenOnBackground: this._config.hideScreenOnBackground,\n    };\n  }\n\n  // overidable event handlers\n  onVaultLocked(_event: LockEvent) {}\n  onSessionRestoreError(_err: VaultError) {}\n  onUnlockOnReadyError(_err: VaultError) {}\n  onVaultUnlocked(_config: VaultConfig) {}\n  onVaultReady(_config: VaultConfig) {}\n  onSetupError(_error: VaultError) {}\n  onConfigChange(_config: VaultConfig) {};\n  onSessionRestored(_session: T) {};\n  async onPasscodeRequest(_isPasscodeSetRequest: boolean): Promise<string | undefined> { return; };\n\n  private async onReady(vault: IdentityVault) {\n    if (this._readyCalled) { return; }\n    this._readyCalled = true;\n    this.vault = vault;\n    const inUse = await this.vault.isInUse();\n    this._config = vault.config!;\n    const locked = await this.vault.isLocked();\n\n    let restoreSessionError!: VaultError;\n\n    try {\n      if (this.options.restoreSessionOnReady && inUse) {\n        await this._restoreSession();\n      }\n    } catch(e) {\n      restoreSessionError = e;\n    }\n\n    let unlockOnReadyError!: VaultError;\n    try {\n      if (locked && this.options.unlockOnReady) {\n        await this._unlock();\n      }\n    } catch(e) {\n      unlockOnReadyError = e;\n    }\n\n    // Note Swallow all errors in init like Vault is Locked Etc.\n    try {\n      if (!inUse) {\n        await this._trySetAuthMode(this.options.authMode);\n      }\n    } catch (e) { }\n    this._readyResolve();\n    this.onVaultReady(this.config);\n    if (restoreSessionError) {\n      this.onSessionRestoreError(restoreSessionError);\n    }\n    if (unlockOnReadyError) {\n      this.onUnlockOnReadyError(restoreSessionError);\n    }\n  }\n\n  private onLock(event: LockEvent) {\n    this.session = undefined;\n    this.onVaultLocked(event);\n  }\n\n  private async onUnlock(config: PluginConfiguration) {\n    await this.ready();\n    this._config = config;\n    this.onVaultUnlocked(this.config);\n  }\n\n  private onError(error: VaultError) {\n    this._readyReject(error);\n    this.onSetupError(error);\n  }\n\n  private onConfig(config: PluginConfiguration) {\n    this._config = config;\n    this.onConfigChange(this.config);\n  }\n\n  public async ready(): Promise<void> {\n    return this._readyPromise;\n  }\n\n  private async _unlock(authMode?: AuthMode): Promise<void> {\n    const locked = await this.vault.isLocked();\n    if (!locked) { return; }\n    authMode = authMode !== undefined && authMode !== AuthMode.BiometricOrPasscode ? authMode : this.config.authMode;\n    switch (authMode) {\n      case AuthMode.BiometricOnly:\n        return this.vault.unlock();\n      case AuthMode.PasscodeOnly:\n        return this.unlockWithPasscode();\n      case AuthMode.BiometricAndPasscode:\n        try {\n          await this.vault.unlock();\n          return;\n        } catch(e) {\n          const handleableErrors = [\n            VaultErrorCodes.AuthFailed,\n            VaultErrorCodes.BiometricsNotEnabled,\n            VaultErrorCodes.UserCanceledInteraction,\n            VaultErrorCodes.InvalidatedCredential,\n          ];\n          if (handleableErrors.indexOf(e.code) > -1) {\n            await this.unlockWithPasscode();\n            // The user removed fingerprints/faceID and so the bio creds are gone\n            // if they are using passcode auth we can resave the credential to autoreset\n            // the mode to PasscodeOnly if bio is no longer available.\n            if (e.code === VaultErrorCodes.InvalidatedCredential) {\n              const session = await this.restoreSession();\n              await this.saveSession(session!);\n            }\n            return;\n          }\n          throw e;\n        }\n    }\n  }\n\n  public async unlock(authMode?: AuthMode): Promise<void>{\n    await this.ready();\n    return this._unlock(authMode);\n  }\n\n  private async unlockWithPasscode() {\n    const passcode = await this.onPasscodeRequest(false);\n    return this.vault.unlock(true, passcode)\n  }\n\n  private async _setPasscode(){\n    const locked = await this.vault.isLocked();\n    if (locked){\n      throw {code: VaultErrorCodes.VaultLocked, message: \"Operation not allowed while vault locked.\"}\n    }\n    const passcode = await this.onPasscodeRequest(true);\n    return this.vault.setPasscode(passcode);\n  }\n\n  public async setPasscode(): Promise<void> {\n    await this.ready();\n    return this._setPasscode();\n  }\n\n  public async getSession(): Promise<T | undefined> {\n    await this.ready();\n    if (this.options.unlockOnAccess) {\n      await this._unlock();\n    }\n    return this.session;\n  }\n\n  private async _restoreSession(): Promise<T | undefined> {\n    const inUse = await this.vault.isInUse();\n    if (!inUse) {\n      return;\n    }\n    if (this.options.unlockOnAccess) {\n      await this._unlock();\n    }\n    this.session  = await this.vault.getValue('session');\n    this.onSessionRestored(this.session!);\n    return this.session;\n  }\n\n  public async restoreSession(): Promise<T | undefined> {\n    await this.ready();\n    return this._restoreSession();\n  }\n\n  public async saveSession(session: T): Promise<void> {\n    await this.ready();\n    if (this.config.isPasscodeSetupNeeded) {\n      await this.setPasscode();\n    }\n    try {\n      await this.vault.storeValue('session', session);\n    } catch (e) {\n      // Catch the case where Biometrics with Passcode Fallback\n      // was enabled but the user disabled passcode or removed their\n      // fingerprints/faceid and try to recover by setting to passcode only\n      // mode.\n      if (e.code === VaultErrorCodes.SecurityNotAvailable) {\n        const authMode = await this.getAuthMode();\n        if (authMode === AuthMode.BiometricAndPasscode) {\n          await this.setAuthMode(AuthMode.PasscodeOnly);\n          return this.saveSession(session);\n        }\n      }\n      throw e;\n    }\n    this.session = session;\n  }\n\n  public async login(session: T, authMode?: AuthMode): Promise<void> {\n    await this.ready();\n    await this.logout();\n    await this._trySetAuthMode(authMode);\n    return this.saveSession(session);\n  }\n\n  public async getVault(): Promise<IdentityVault> {\n    await this.ready();\n    return this.vault;\n  }\n\n  private async initializeVault(): Promise<void> {\n    await this.platform.ready();\n\n    if (this.vault != null) {\n      return Promise.resolve();\n    }\n\n    if (this.vIonicNativeAuth == null) {\n      this.vIonicNativeAuth = this.getPlugin();\n    }\n\n    const readyPromise = new Promise<void>((resolve, reject) => {\n      this._readyResolve = resolve;\n      this._readyReject = reject;\n    });\n\n    const {\n      lockAfter,\n      hideScreenOnBackground,\n      shouldClearVaultAfterTooManyFailedAttempts,\n      allowSystemPinFallback,\n      androidPromptNegativeButtonText,\n      androidPromptTitle,\n      androidPromptSubtitle,\n      androidPromptDescription,\n      iosPromptText\n    } = this.options;\n\n    this.vault = this.vIonicNativeAuth.getVault({\n      lockAfter,\n      hideScreenOnBackground,\n      shouldClearVaultAfterTooManyFailedAttempts,\n      allowSystemPinFallback,\n      androidPromptNegativeButtonText,\n      androidPromptTitle,\n      androidPromptSubtitle,\n      androidPromptDescription,\n      iosPromptText,\n      ...this.descriptor,\n      onLock: this.onLock.bind(this),\n      onConfig: this.onConfig.bind(this),\n      onError: this.onError.bind(this),\n      onUnlock: this.onUnlock.bind(this),\n      onReady: this.onReady.bind(this),\n    });\n\n    return readyPromise;\n  }\n\n  public getPlugin(): IonicNativeAuthPlugin {\n    return IonicNativeAuth;\n  }\n\n  public async getBiometricType(): Promise<BiometricType> {\n    await this.ready();\n    return this.vault.getBiometricType();\n  }\n\n  public async getAvailableHardware(): Promise<SupportedBiometricType[]> {\n    await this.ready();\n    return this.vault.getAvailableHardware();\n  }\n\n  public async lockOut(): Promise<void> {\n    await this.ready();\n    await this.vault.lock();\n    this.session = undefined;\n  }\n\n  public async logout(): Promise<void> {\n    await this.ready();\n    await this.vault.clear();\n    this.session = undefined;\n    this._config = await this.vault.getConfig();\n  }\n\n  public async hasStoredSession() {\n    await this.ready();\n    return this.vault.isInUse();\n  }\n\n  public async setBiometricsEnabled(isBiometricsEnabled: boolean): Promise<void> {\n    await this.ready();\n    return this._setBiometricsEnabled(isBiometricsEnabled);\n  }\n\n  private async _setBiometricsEnabled(isBiometricsEnabled: boolean): Promise<void> {\n    return this.vault.setBiometricsEnabled(isBiometricsEnabled);\n  }\n\n  public async setHideScreenOnBackground(enabled: boolean): Promise<void> {\n    await this.ready();\n    return this.vault.setHideScreenOnBackground(enabled);\n  }\n\n  public async setPasscodeEnabled(isPasscodeEnabled: boolean): Promise<void> {\n    await this.ready();\n    await this._setPasscodeEnabled(isPasscodeEnabled);\n  }\n\n  private async _setPasscodeEnabled(isPasscodeEnabled: boolean): Promise<void> {\n    await this.vault.setPasscodeEnabled(isPasscodeEnabled);\n    this._config = await this.vault.getConfig();\n    if (this.config.isPasscodeSetupNeeded) {\n      await this._setPasscode();\n    }\n  }\n\n  public async isBiometricsEnabled(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isBiometricsEnabled();\n  }\n\n  public async isBiometricsAvailable(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isBiometricsAvailable();\n  }\n\n  public async isBiometricsSupported(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isBiometricsSupported();\n  }\n\n  public async isSecureStorageModeEnabled(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isSecureStorageModeEnabled();\n  }\n\n  public async isPasscodeEnabled(): Promise<boolean> {\n    await this.ready();\n    return this.vault.isPasscodeEnabled();\n  }\n\n  private async _setAuthMode(authMode?: AuthMode) {\n    authMode = authMode !== undefined ? authMode : this.config.authMode;\n    if (authMode === this.config.authMode) {\n      return;\n    }\n    switch(authMode) {\n      case AuthMode.BiometricOnly:\n        await this._setBiometricsEnabled(true);\n        await this._setPasscodeEnabled(false);\n        break;\n      case AuthMode.PasscodeOnly:\n        await this._setPasscodeEnabled(true);\n        await this._setBiometricsEnabled(false);\n        break;\n      case AuthMode.BiometricAndPasscode:\n        await this._setPasscodeEnabled(true);\n        await this._setBiometricsEnabled(true);\n        break;\n      case AuthMode.BiometricOrPasscode:\n        try {\n          await this._setBiometricsEnabled(true);\n          await this._setPasscodeEnabled(false);\n        } catch (error) {\n          await this._setPasscodeEnabled(true);\n        }\n        break;\n      case AuthMode.InMemoryOnly:\n        await this._setPasscodeEnabled(false);\n        await this._setBiometricsEnabled(false);\n        await this.vault.setSecureStorageModeEnabled(false);\n        break;\n      case AuthMode.SecureStorage:\n        // Note: Setting this mode automatically disables the other modes in native code.\n        await this.vault.setSecureStorageModeEnabled(true);\n        break;\n      default:\n        throw {code: VaultErrorCodes.InvalidAuthMode, message: \"Invalid AuthMode\"};\n    }\n  }\n\n  private async _trySetAuthMode(authMode?: AuthMode) {\n    try {\n      await this._setAuthMode(authMode);\n    } catch (error) {\n      if (\n        error.code !== VaultErrorCodes.BiometricsNotEnabled &&\n        error.code !== VaultErrorCodes.SecurityNotAvailable\n      ) {\n        throw error;\n      }\n    }\n  }\n\n  public async setAuthMode(authMode?: AuthMode) {\n    await this.ready();\n    return this._setAuthMode(authMode);\n  }\n\n  public async getAuthMode(): Promise<AuthMode> {\n    await this.ready();\n    this._config = await this.vault.getConfig();\n    return this.config.authMode!;\n  }\n}\n","import { VaultDescriptor, VaultOptions } from \"./definitions\";\nimport { IonicIdentityVaultUser } from \"./vault-user\";\n\ntype onPasscodeRequestCallback = (\n  _isPasscodeSetRequest: boolean\n) => Promise<string | undefined>;\n\nclass MigratorVault extends IonicIdentityVaultUser<any> {\n  private static instance: MigratorVault | undefined = undefined;\n\n  private constructor(\n    options: VaultOptions,\n    onPasscodeRequest?: onPasscodeRequestCallback,\n    descriptor?: VaultDescriptor\n  ) {\n    super(\n      {\n        ready: () => Promise.resolve(true),\n      },\n      options,\n      descriptor\n    );\n\n    if (onPasscodeRequest) {\n      this.onPasscodeRequest = onPasscodeRequest;\n    }\n  }\n\n  public static getInstance(\n    options: VaultOptions,\n    onPasscodeRequest?: onPasscodeRequestCallback,\n    descriptor?: VaultDescriptor\n  ): MigratorVault {\n    if (!MigratorVault.instance) {\n      MigratorVault.instance = new MigratorVault(\n        options,\n        onPasscodeRequest,\n        descriptor\n      );\n    }\n    return MigratorVault.instance;\n  }\n}\n\nexport class VaultMigrator {\n  /** @ignore */\n  private migratorSession: MigratorVault;\n\n  /**\n   *\n   * @usage\n   * ```typescript\n   * const legacyVaultConfig = {\n   *  unlockOnAccess: true,\n   *  hideScreenOnBackground: true,\n   *  lockAfter: 5000,\n   *  // and more ....\n   * }\n   * const migrator = new VaultMigrator(legacyVaultConfig, customPasscodePrompt);\n   * ```\n   * @param options The legacy vault configuration options\n   * @param onPasscodeRequest An optional callback function that will be called when the vault attempts to request a passcode. The function returns a promise with a boolean that indicates if the passcode is being setup for the first time for the vault or not.\n   * @param descriptor An optional interface that describes the legacy vault.\n   */\n  constructor(\n    options: VaultOptions,\n    onPasscodeRequest?: (\n      isPasscodeSetRequest: boolean\n    ) => Promise<string | undefined>,\n    descriptor?: VaultDescriptor\n  ) {\n    this.migratorSession = MigratorVault.getInstance(\n      options,\n      onPasscodeRequest,\n      descriptor\n    );\n  }\n\n  /**\n   * Exports the data of the legacy vault in its entirety.\n   *\n   * @usage\n   * ```typescript\n   * const data = await migrator.exportVault();\n   * console.log(\"@@VAULT DATA: \", JSON.stringify(data));\n   * ```\n   * @returns\n   */\n  async exportVault(): Promise<any | null> {\n    if (!(await this.migratorSession.hasStoredSession())) {\n      throw Error(\"no data in legacy vault\");\n    }\n\n    await this.migratorSession.unlock();\n\n    const vault = await this.migratorSession.getVault();\n    const keys = await vault.getKeys();\n\n    let vaultData: any = {};\n\n    for (let i = 0; i < keys.length; i++) {\n      const keyValue = await vault.getValue(keys[i]);\n      vaultData[keys[i]] = keyValue;\n    }\n\n    return vaultData;\n  }\n\n  /**\n   * Clears out the legacy vault and removes it from the system.  Be sure to run {@link VaultMigrator.exportVault} before calling this method.\n   *\n   * @usage\n   * ```typescript\n   * const data = await migrator.exportVault();\n   * await importVault(data);\n   * await migrator.clear();\n   * ```\n   */\n  async clear(): Promise<void> {\n    const vault = await this.migratorSession.getVault();\n    return vault.clear();\n  }\n}\n"],"names":[],"mappings":"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"}