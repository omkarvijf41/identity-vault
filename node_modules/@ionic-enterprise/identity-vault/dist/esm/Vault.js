import { AndroidBiometricCryptoPreference, DeviceSecurityType, VaultErrorCodes, VaultType } from './definitions';
/**
 * Represents a vault for secure value storage
 */
export class Vault {
    /**
     * @usage
     * ```typescript
     * const vault = new Vault({
     *  key: 'com.company.myvaultapp',
     *  type: 'CustomPasscode',
     *  deviceSecurityType: DeviceSecurityType.None,
     *  lockAfterBackgrounded: 2000,
     * });
     * ```
     * @param config
     */
    constructor(config) {
        /** @ignore */
        this.defaultConfig = {
            deviceSecurityType: DeviceSecurityType.None,
            androidBiometricsPreferStrongVaultOrSystemPasscode: AndroidBiometricCryptoPreference.StrongVault,
            shouldClearVaultAfterTooManyFailedAttempts: false,
            customPasscodeInvalidUnlockAttempts: 5,
            unlockVaultOnLoad: false,
        };
        // set defaults
        this.config = Object.assign(this.defaultConfig, config);
        // setting sane defaults
        if (config.deviceSecurityType === DeviceSecurityType.None && config.type === VaultType.DeviceSecurity) {
            config.deviceSecurityType = DeviceSecurityType.Both;
        }
        this.resume = this.resume.bind(this);
        this.handleError = this.handleError.bind(this);
        this.setup().then(() => {
            this.getPersistedVaultConfig();
        });
    }
    /**
     * Resolves true if a vault with the same key already exists, and false if not.
     * The vault does not need to be unlocked to check.
     *
     * __Note:__
     *  - Using {@link Vault.removeValue | removeValue()} to remove all of your vault data will not cause this function to resolve false, however {@link Vault.clear | clear()} will.
     *  - A vault only exists once it has been interacted with at least once via any of the following instance methods.
     *    - {@link Vault.setValue | setValue()}
     *    - {@link Vault.removeValue | removeValue()}
     *    - {@link Vault.importVault | importVault()}
     *    - {@link Vault.exportVault | exportVault()}
     *    - {@link Vault.unlock | unlock()}
     *    - {@link Vault.updateConfig | updateConfig()}
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const vaultExists = await vault.doesVaultExists()
     * if (!vaultExists) {
     *  // the vault does not exist...
     * }
     * ```
     *
     * @deprecated Deprecated in favor of using the {@link Vault.isEmpty | isEmpty()} method.
     */
    doesVaultExist() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.doesVaultExist());
            }, 'VaultPlugin', 'doesVaultExist', [this.config]);
        });
    }
    /**
     * Clears out the current vault and removes it from the system.
     * Note: The vault does not need to be unlocked in order to clear it. No credentials are checked
     * when clearing the vault.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.clear();
     * ```
     */
    clear() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve();
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.clear());
            }, 'VaultPlugin', 'clear', [this.config]);
        });
    }
    /**
     * Exports the data of the current vault in its entirety.
     * The data is a map with keys that are strings and values that are JSON.
     * Calling `exportVault` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const data = await vault.exportVault();
     * ```
     *
     * @return The resolved object is a map with string keys and string values.
     *
     */
    exportVault() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.exportVault());
            }, 'VaultPlugin', 'exportVault', [this.config]);
        });
    }
    /**
     * Imports data into the vault, replacing the current contents of the vault.
     * The data is a map with keys that are strings and values that are JSON.
     * Calling `importVault` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const dataFromElsewhere = await getUserData();
     * const newVault = new Vault(vaultConfig);
     * await newVault.importVault(dataFromElsewhere);
     * ```
     *
     * @param data The entire data object to be imported. The shape of data must be {[key: string]: string}.
     *
     */
    importVault(data) {
        const jsonData = JSON.stringify(data);
        return new Promise((resolve, reject) => {
            cordova.exec(resolve, (error) => {
                this.handleError(resolve, reject, error, () => this.importVault(data));
            }, 'VaultPlugin', 'importVault', [this.config, jsonData]);
        });
    }
    /**
     * Checks if the vault is currently in a locked state, which signifies that the contents
     * of the secure vault are not currently accessible. `isLocked` can also return true if the
     * vault does not exist.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const locked = await vault.isLocked();
     * if (locked) {
     *  // vault is locked (or does not exist);
     * }
     * ```
     */
    isLocked() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'isLocked', [this.config]);
        });
    }
    /**
     * Returns an array of keys that are currently in the vault.
     * Calling `getKeys` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const allKeys = await vault.getKeys();
     * allKeys.forEach((key) => {
     *  // do something with the key
     * });
     * ```
     */
    getKeys() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.getKeys());
            }, 'VaultPlugin', 'getKeys', [this.config]);
        });
    }
    /**
     * Gets the value for a given key. Returns null if the key does not exist.
     * Calling `getValue` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const userFirstName = await vault.getValue<string>("firstname");
     * ```
     *
     * @param key The key to look up the value for
     *
     */
    getValue(key) {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                if (!data) {
                    // android returns null as an empty string, so manually convert it here
                    resolve(null);
                }
                else {
                    try {
                        resolve(JSON.parse(data));
                    }
                    catch (err) {
                        resolve(data);
                    }
                }
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.getValue(key));
            }, 'VaultPlugin', 'getValue', [this.config, key]);
        });
    }
    /**
     * Locks the vault if it is currently unlocked.
     * Locking the vault with remove all secure data from memory inside of Identity Vault, but not your application.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.lock();
     * ```
     */
    lock() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve();
            }, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'lock', [this.config]);
        });
    }
    /**
     * Removes a value from the vault.
     * Calling `removeValue` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.removeValue("address");
     * ```
     *
     * @param key The key to remove
     *
     */
    removeValue(key) {
        return new Promise((resolve, reject) => {
            cordova.exec(resolve, (error) => {
                this.handleError(resolve, reject, error, () => this.removeValue(key));
            }, 'VaultPlugin', 'removeValue', [this.config, key]);
        });
    }
    /**
     * When the vault type is set to 'CustomPasscode', this method sets the passcode required to
     * secure the vault.
     * This method is typically called in the `onPasscodeRequested` callback.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const code = window.prompt("Enter your passcode.");
     * if (code) {
     *  await vault.setCustomPasscode(code);
     * }
     * ```
     *
     * @param passcode The user supplied passcode to secure the vault with.
     *
     */
    setCustomPasscode(passcode) {
        return new Promise((resolve, reject) => {
            cordova.exec(resolve, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'setCustomPasscode', [this.config, passcode]);
        });
    }
    /**
     * Sets the value of an item in the vault.
     * Calling `setValue` will attempt to unlock the vault if it is currently locked.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.setValue<string>("theme", theme);
     * ```
     *
     * @param key The key for the new value.
     * @param value The value to store in the vault. Value can be of any type, as it will be parsed to JSON in the vault.
     *
     */
    setValue(key, value) {
        const jsonValue = JSON.stringify(value);
        return new Promise((resolve, reject) => {
            cordova.exec(resolve, (error) => {
                this.handleError(resolve, reject, error, () => this.setValue(key, value));
            }, 'VaultPlugin', 'setValue', [this.config, key, jsonValue]);
        });
    }
    /**
     * Triggers when a config change occurs.
     *
     * @usage
     * ```typescript
     * vault.onConfigChanged((config) => {
     *  console.log("updated config: ", config);
     * });
     * ```
     * @param callback The callback function that will be called when the event triggers. Passes in the current vault config.
     *
     */
    onConfigChanged(callback) {
        cordova.exec((data) => {
            callback(JSON.parse(data));
        }, (error) => console.error(error), 'VaultPlugin', 'onConfigChanged', []);
    }
    /**
     * Triggers when an error occurs in the application.
     * Errors that come back as rejected promises also trigger this event.
     *
     * @usage
     * ```typescript
     * vault.onError((err) => {
     *  console.log('ERROR from callback', JSON.stringify(err));
     * });
     * ```
     *
     * @param callback The callback function that will be called when the event triggers. Passes in the error object.
     *
     */
    onError(callback) {
        cordova.exec(() => {
            // Do Nothing
        }, callback, 'VaultPlugin', 'onError', []);
    }
    /**
     * Triggers when the vault enters a locked state.
     *
     * @usage
     * ```typescript
     * vault.onLock(() => { displayNotification("Vault locked."); })
     * ```
     *
     * @param callback The callback function that will be called when the event triggers.
     *
     */
    onLock(callback) {
        cordova.exec(callback, (error) => console.error(error), 'VaultPlugin', 'onLock', [this.config]);
    }
    onPasscodeRequested(callback) {
        this.passCodeRequestedCallback = callback;
    }
    /**
     * Triggers when the vault enters an unlocked state.
     *
     * @usage
     * ```typescript
     * vault.onUnlock(() => {
     *  console.log("vault is now unlocked");
     * });
     * ```
     * @param callback The callback function that will be called when the event triggers.
     *
     */
    onUnlock(callback) {
        cordova.exec(callback, (error) => console.error(error), 'VaultPlugin', 'onUnlock', [this.config]);
    }
    /**
     * Manually unlock the vault. Will trigger any authentication mechanism needed to access the vault (passcode, biometrics, etc..).
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * await vault.unlock();
     * ```
     */
    unlock() {
        return new Promise((resolve, reject) => {
            cordova.exec(() => {
                resolve();
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.unlock());
            }, 'VaultPlugin', 'unlock', [this.config]);
        });
    }
    /**
     * Updates the configuration of the current vault.
     *
     *  @usage
     * ```typescript
     * async function changeVaultType(type: VaultType) {
     *  const vault = new Vault(this.existingVaultConfig);
     *  const newConfig = { ...this.existingVaultConfig, type };
     *  await vault.updateConfig(newConfig);
     *  this.existingVaultConfig = newConfig;
     * }
     * ```
     *
     * @param config The new config
     *
     */
    updateConfig(config) {
        return new Promise((resolve, reject) => {
            config = Object.assign(this.defaultConfig, config);
            // setting sane defaults
            if (config.deviceSecurityType === DeviceSecurityType.None && config.type === VaultType.DeviceSecurity) {
                config.deviceSecurityType = DeviceSecurityType.Both;
            }
            cordova.exec(() => {
                this.config = config;
                resolve();
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.updateConfig(config));
            }, 'VaultPlugin', 'updateConfig', [config]);
        });
    }
    /**
     * Resolves true if a vault contains no data, and false if any data exists in the vault.
     * The vault does not need to be unlocked to check.
     *
     * __Note:__ Vaults created prior to version 5.2.0 will return false until the vault is unlocked for the first time after updating, even if the vault contains no data.
     * After which this method will return the expected value.
     *
     * @usage
     * ```typescript
     * const vault = new Vault(existingVaultConfig);
     * const vaultIsEmpty = await vault.isEmpty()
     * if (vaultIsEmpty) {
     *  // the vault is empty and contains no data...
     * }
     * ```
     */
    isEmpty() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'isEmpty', [this.config]);
        });
    }
    /** @ignore */
    async handleError(resolve, reject, error, retryFunc) {
        if (error.code === VaultErrorCodes.MissingPasscode && this.passCodeRequestedCallback) {
            const checkRetry = async () => {
                if (retryFunc) {
                    try {
                        const data = await retryFunc();
                        resolve(data);
                    }
                    catch (e) {
                        reject(e);
                    }
                }
            };
            const res = this.passCodeRequestedCallback(error.extra.isPasscodeSetRequest, (code) => {
                this.setCustomPasscode(code);
                checkRetry();
            });
            if (res instanceof Promise) {
                await res;
                await checkRetry();
            }
        }
        else if (error.code === VaultErrorCodes.MissingBiometrics) {
            cordova.exec(async () => {
                const data = await retryFunc();
                resolve(data);
            }, (e) => reject(e), 'VaultPlugin', 'requestBiometricPrompt', [this.config]);
        }
        else {
            reject(error);
        }
    }
    /** @ignore */
    requestBiometricPrompt() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                resolve(JSON.parse(data));
            }, (error) => {
                this.handleError(resolve, reject, error, () => this.requestBiometricPrompt());
            }, 'VaultPlugin', 'requestBiometricPrompt', [this.config]);
        });
    }
    /**
     * @ignore
     */
    resume() {
        const noop = () => {
            // Do Nothing
        };
        cordova.exec(noop, (error) => {
            this.handleError(noop, noop, error, () => this.resume());
        }, 'VaultPlugin', 'appResumed', [this.config]);
    }
    /**
     * @ignore
     */
    setup() {
        return new Promise((resolve, reject) => {
            document.addEventListener('resume', this.resume, false);
            cordova.exec(resolve, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'setup', [this.config]);
        });
    }
    /**
     * @ignore
     */
    getPersistedVaultConfig() {
        return new Promise((resolve, reject) => {
            cordova.exec((data) => {
                if (!data) {
                    resolve();
                }
                else {
                    const vaultConfig = JSON.parse(data);
                    this.config = Object.assign(this.config, vaultConfig);
                    resolve();
                }
            }, (error) => {
                this.handleError(resolve, reject, error);
            }, 'VaultPlugin', 'getVaultConfig', [this.config]);
        });
    }
}
//# sourceMappingURL=Vault.js.map