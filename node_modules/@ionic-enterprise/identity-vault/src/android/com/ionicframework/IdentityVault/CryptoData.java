package com.ionicframework.IdentityVault;

import android.os.Build;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyInfo;
import android.security.keystore.KeyProperties;
import android.util.Base64;

import androidx.annotation.RequiresApi;

import com.bottlerocketstudios.vault.EncryptionConstants;

import org.json.JSONException;
import org.json.JSONObject;

import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;

@RequiresApi(api = Build.VERSION_CODES.M)
public class CryptoData {
    public byte[] salt;
    public byte[] iv;
    public byte[] data;

    private CryptoData() {
    }

    public static CryptoData create(byte[] data, byte[] iv, byte[] salt) {
        CryptoData cryptoData = new CryptoData();
        cryptoData.data = data;
        cryptoData.iv = iv;
        cryptoData.salt = salt;
        return cryptoData;
    }

    public static CryptoData create(String jsonString) throws JSONException {
        JSONObject jsonObject = new JSONObject(jsonString);
        CryptoData cryptoData = new CryptoData();
        cryptoData.data = Base64.decode(jsonObject.getString("data").getBytes(StandardCharsets.UTF_8), Base64.DEFAULT);
        cryptoData.iv = Base64.decode(jsonObject.getString("iv").getBytes(StandardCharsets.UTF_8), Base64.DEFAULT);
        cryptoData.salt = Base64.decode(jsonObject.getString("salt").getBytes(StandardCharsets.UTF_8), Base64.DEFAULT);
        return cryptoData;
    }

    public static String encrypt(String alias, String dataJsonString, String customPasscode) throws VaultError {
        try {
            if (customPasscode != null) {
                dataJsonString = PasswordBasedCrypto.encrypt(customPasscode, dataJsonString);
            }
            SecretKey secretKey = getOrCreateKey(alias);
            Cipher cipher = Cipher.getInstance(EncryptionConstants.AES_CBC_PADDED_TRANSFORM_ANDROID_M);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] iv = cipher.getIV();
            byte[] dataBytes = dataJsonString.getBytes(StandardCharsets.UTF_8);
            byte[] encryptedBytes = cipher.doFinal(dataBytes);
            CryptoData cryptoData = CryptoData.create(encryptedBytes, iv, new byte[0]);
            return cryptoData.toJSON();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
            throw new UnexpectedKeystoreError(e.getLocalizedMessage());
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    public static String decrypt(String alias, String encryptedDataJson, String customPasscode) throws VaultError {
        try {
            CryptoData cryptoData = CryptoData.create(encryptedDataJson);
            SecretKey secretKey = getOrCreateKey(alias);
            Cipher cipher = Cipher.getInstance(EncryptionConstants.AES_CBC_PADDED_TRANSFORM_ANDROID_M);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(cryptoData.iv));
            byte[] decryptedDataBytes = cipher.doFinal(cryptoData.data);
            String decryptedDataJson = new String(decryptedDataBytes, StandardCharsets.UTF_8);
            if (customPasscode != null) {
                CryptoData encryptedPasscodeData = CryptoData.create(decryptedDataJson);
                decryptedDataJson = PasswordBasedCrypto.decrypt(customPasscode, encryptedPasscodeData);
            }
            return decryptedDataJson;
        } catch (InvalidKeyException e) {
            e.printStackTrace();
            throw new UnexpectedKeystoreError(e.getLocalizedMessage());
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    public String toJSON() throws JSONException {
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("data", Base64.encodeToString(this.data, Base64.DEFAULT));
        jsonObject.put("iv", Base64.encodeToString(this.iv, Base64.DEFAULT));
        jsonObject.put("salt", Base64.encodeToString(this.salt, Base64.DEFAULT));
        return jsonObject.toString();
    }
    
    private static SecretKey getOrCreateKey(String key) throws VaultError {
        try {
            KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
            keyStore.load(null);
            SecretKey secretKey = (SecretKey) keyStore.getKey(key, null);
            if (secretKey == null) {

                KeyGenerator keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore");
                KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(
                        key,
                        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                        .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                        .setUserAuthenticationRequired(false)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_PKCS7);

                boolean supportsHardwareSecurity = Device.getInstance().hasSecureHardware();

                if (Build.VERSION.SDK_INT >= 28 && supportsHardwareSecurity) {
                    builder.setIsStrongBoxBacked(true);
                }

                keyGenerator.init(builder.build());
                secretKey = keyGenerator.generateKey();
            }

            return secretKey;
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }
}

@RequiresApi(api = Build.VERSION_CODES.M)
class PasswordBasedCrypto {

    static int iterationCount = 1000;
    static int saltLength = 8;
    static int ivLength = 16;
    static String pbkAlgorithm = "PBEwithSHA256and128BITAES-CBC-BC";
    static String encryptionAlgorithm = "AES/CBC/PKCS5Padding";

    public static String encrypt(String password, String value) throws VaultError {
        try {
            byte[] salt = new byte[saltLength];
            byte[] iv = new byte[ivLength];
            SecureRandom random = new SecureRandom();
            random.nextBytes(salt);
            random.nextBytes(iv);
            byte[] encryptedBytes = getCryptoBytes(Cipher.ENCRYPT_MODE, password, value.getBytes(StandardCharsets.UTF_8), salt, iv);
            CryptoData cryptoData = CryptoData.create(encryptedBytes, iv, salt);
            return cryptoData.toJSON();
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    public static String decrypt(String password, CryptoData cryptoData) throws VaultError {
        try {
            byte[] decryptedBytes = getCryptoBytes(Cipher.DECRYPT_MODE, password, cryptoData.data, cryptoData.salt, cryptoData.iv);
            return new String(decryptedBytes, StandardCharsets.UTF_8);
        } catch (BadPaddingException e) {
            throw new AuthFailedError();
        } catch (Exception e) {
            throw new VaultError(e.getLocalizedMessage());
        }
    }

    private static byte[] getCryptoBytes(int mode, String password, byte[] data, byte[] salt, byte[] iv) throws InvalidKeySpecException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, iterationCount);
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(pbkAlgorithm);
        SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        Cipher cipher = Cipher.getInstance(encryptionAlgorithm);
        cipher.init(mode, secretKey, ivSpec);
        return cipher.doFinal(data);
    }
}

