(function () {
  "use strict";

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  (self["webpackChunkgetting_started_iv_angular"] = self["webpackChunkgetting_started_iv_angular"] || []).push([["node_modules_ionic_core_dist_esm_ion-picker-column-internal_entry_js"], {
    /***/
    42322: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "ion_picker_column_internal": function ion_picker_column_internal() {
          return (
            /* binding */
            PickerColumnInternal
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./index-06cd27b1.js */
      88179);
      /* harmony import */


      var _ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./ionic-global-a049bcbf.js */
      88278);
      /* harmony import */


      var _helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! ./helpers-6ff04165.js */
      48423);
      /* harmony import */


      var _haptic_9a9aa7ec_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! ./haptic-9a9aa7ec.js */
      63149);
      /* harmony import */


      var _theme_a24ff1ad_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! ./theme-a24ff1ad.js */
      91526);
      /*!
       * (C) Ionic http://ionicframework.com - MIT License
       */


      var pickerColumnInternalIosCss = ":host{padding-left:16px;padding-right:16px;padding-top:0px;padding-bottom:0px;height:200px;outline:none;font-size:22px;-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory;overflow-x:hidden;overflow-y:scroll;scrollbar-width:none;text-align:center}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}:host::-webkit-scrollbar{display:none}:host .picker-item{height:34px;line-height:34px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;scroll-snap-align:center}:host .picker-item-empty{scroll-snap-align:none}:host(.picker-column-active) .picker-item.picker-item-active{color:var(--ion-color-base)}@media (any-hover: hover){:host(:focus){outline:none;background:rgba(var(--ion-color-base-rgb), 0.2)}}";
      var pickerColumnInternalMdCss = ":host{padding-left:16px;padding-right:16px;padding-top:0px;padding-bottom:0px;height:200px;outline:none;font-size:22px;-webkit-scroll-snap-type:y mandatory;-ms-scroll-snap-type:y mandatory;scroll-snap-type:y mandatory;overflow-x:hidden;overflow-y:scroll;scrollbar-width:none;text-align:center}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){:host{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}:host::-webkit-scrollbar{display:none}:host .picker-item{height:34px;line-height:34px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;scroll-snap-align:center}:host .picker-item-empty{scroll-snap-align:none}:host(.picker-column-active) .picker-item.picker-item-active{color:var(--ion-color-base)}@media (any-hover: hover){:host(:focus){outline:none;background:rgba(var(--ion-color-base-rgb), 0.2)}}:host .picker-item-active{color:var(--ion-color-base)}";

      var PickerColumnInternal = /*#__PURE__*/function () {
        function PickerColumnInternal(hostRef) {
          var _this = this;

          _classCallCheck(this, PickerColumnInternal);

          (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.r)(this, hostRef);
          this.ionChange = (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.e)(this, "ionChange", 7);
          this.hapticsStarted = false;
          this.isActive = false;
          /**
           * A list of options to be displayed in the picker
           */

          this.items = [];
          /**
           * The color to use from your application's color palette.
           * Default options are: `"primary"`, `"secondary"`, `"tertiary"`, `"success"`, `"warning"`, `"danger"`, `"light"`, `"medium"`, and `"dark"`.
           * For more information on colors, see [theming](/docs/theming/basics).
           */

          this.color = 'primary';
          /**
           * If `true`, tapping the picker will
           * reveal a number input keyboard that lets
           * the user type in values for each picker
           * column. This is useful when working
           * with time pickers.
           *
           * @internal
           */

          this.numericInput = false;

          this.centerPickerItemInView = function (target) {
            var smooth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

            _this.el.scroll({
              // (Vertical offset from parent) - (three empty picker rows) + (half the height of the target to ensure the scroll triggers)
              top: target.offsetTop - 3 * target.clientHeight + target.clientHeight / 2,
              left: 0,
              behavior: smooth ? 'smooth' : undefined
            });
          };
          /**
           * When ionInputModeChange is emitted, each column
           * needs to check if it is the one being made available
           * for text entry.
           */


          this.inputModeChange = function (ev) {
            if (!_this.numericInput) {
              return;
            }

            var _ev$detail = ev.detail,
                inputMode = _ev$detail.inputMode,
                inputModeColumn = _ev$detail.inputModeColumn;
            /**
             * If inputModeColumn is undefined then this means
             * all numericInput columns are being selected.
             */

            var isColumnActive = inputModeColumn === undefined || inputModeColumn === _this.el;

            if (!inputMode || !isColumnActive) {
              _this.isActive = false;
              return;
            }

            _this.isActive = true;
          };
          /**
           * When the column scrolls, the component
           * needs to determine which item is centered
           * in the view and will emit an ionChange with
           * the item object.
           */


          this.initializeScrollListener = function () {
            var el = _this.el;
            var timeout;
            var activeEl = _this.activeItem;

            var scrollCallback = function scrollCallback() {
              (0, _helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_2__.r)(function () {
                if (timeout) {
                  clearTimeout(timeout);
                  timeout = undefined;
                }

                if (!_this.hapticsStarted) {
                  (0, _haptic_9a9aa7ec_js__WEBPACK_IMPORTED_MODULE_3__.a)();
                  _this.hapticsStarted = true;
                }
                /**
                 * Select item in the center of the column
                 * which is the month/year that we want to select
                 */


                var bbox = el.getBoundingClientRect();
                var centerX = bbox.x + bbox.width / 2;
                var centerY = bbox.y + bbox.height / 2;
                var activeElement = el.shadowRoot.elementFromPoint(centerX, centerY);

                if (activeEl !== null) {
                  activeEl.classList.remove(PICKER_COL_ACTIVE);
                }
                /**
                 * If we are selecting a new value,
                 * we need to run haptics again.
                 */


                if (activeElement !== activeEl) {
                  (0, _haptic_9a9aa7ec_js__WEBPACK_IMPORTED_MODULE_3__.b)();
                }

                activeEl = activeElement;
                activeElement.classList.add(PICKER_COL_ACTIVE);
                timeout = setTimeout(function () {
                  var dataIndex = activeElement.getAttribute('data-index');
                  /**
                   * If no value it is
                   * possible we hit one of the
                   * empty padding columns.
                   */

                  if (dataIndex === null) {
                    return;
                  }

                  var index = parseInt(dataIndex, 10);
                  var selectedItem = _this.items[index];

                  if (selectedItem.value !== _this.value) {
                    _this.value = selectedItem.value;
                    (0, _haptic_9a9aa7ec_js__WEBPACK_IMPORTED_MODULE_3__.h)();
                    _this.hapticsStarted = false;
                  }
                }, 250);
              });
            };
            /**
             * Wrap this in an raf so that the scroll callback
             * does not fire when component is initially shown.
             */


            (0, _helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_2__.r)(function () {
              el.addEventListener('scroll', scrollCallback);

              _this.destroyScrollListener = function () {
                el.removeEventListener('scroll', scrollCallback);
              };
            });
          };
        }

        _createClass(PickerColumnInternal, [{
          key: "valueChange",
          value: function valueChange() {
            var items = this.items,
                value = this.value;
            this.scrollActiveItemIntoView();
            var findItem = items.find(function (item) {
              return item.value === value;
            });

            if (findItem) {
              this.ionChange.emit(findItem);
            }
          }
          /**
           * Only setup scroll listeners
           * when the picker is visible, otherwise
           * the container will have a scroll
           * height of 0px.
           */

        }, {
          key: "componentWillLoad",
          value: function componentWillLoad() {
            var _this2 = this;

            var visibleCallback = function visibleCallback(entries) {
              var ev = entries[0];

              if (ev.isIntersecting) {
                _this2.scrollActiveItemIntoView();

                _this2.initializeScrollListener();
              } else {
                if (_this2.destroyScrollListener) {
                  _this2.destroyScrollListener();

                  _this2.destroyScrollListener = undefined;
                }
              }
            };

            new IntersectionObserver(visibleCallback, {
              threshold: 0.01
            }).observe(this.el);
            var parentEl = this.el.closest('ion-picker-internal');

            if (parentEl !== null) {
              parentEl.addEventListener('ionInputModeChange', function (ev) {
                return _this2.inputModeChange(ev);
              });
            }
          }
        }, {
          key: "scrollActiveItemIntoView",
          value: function scrollActiveItemIntoView() {
            var activeEl = this.activeItem;

            if (activeEl) {
              this.centerPickerItemInView(activeEl, false);
              /**
               * This is needed because the initial
               * scrollActiveItemIntoView call fires before
               * the scroll event listener is setup.
               */

              activeEl.classList.add(PICKER_COL_ACTIVE);
            }
          }
        }, {
          key: "activeItem",
          get: function get() {
            return (0, _helpers_6ff04165_js__WEBPACK_IMPORTED_MODULE_2__.g)(this.el).querySelector(".picker-item[data-value=\"".concat(this.value, "\"]"));
          }
        }, {
          key: "render",
          value: function render() {
            var _ref,
                _this3 = this;

            var items = this.items,
                color = this.color,
                isActive = this.isActive,
                numericInput = this.numericInput;
            var mode = (0, _ionic_global_a049bcbf_js__WEBPACK_IMPORTED_MODULE_1__.b)(this);
            return (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)(_index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.H, {
              tabindex: 0,
              "class": (0, _theme_a24ff1ad_js__WEBPACK_IMPORTED_MODULE_4__.c)(color, (_ref = {}, _defineProperty(_ref, mode, true), _defineProperty(_ref, 'picker-column-active', isActive), _defineProperty(_ref, 'picker-column-numeric-input', numericInput), _ref))
            }, (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
              "class": "picker-item picker-item-empty"
            }, "\xA0"), (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
              "class": "picker-item picker-item-empty"
            }, "\xA0"), (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
              "class": "picker-item picker-item-empty"
            }, "\xA0"), items.map(function (item, index) {
              return (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
                "class": "picker-item",
                "data-value": item.value,
                "data-index": index,
                onClick: function onClick(ev) {
                  _this3.centerPickerItemInView(ev.target);
                }
              }, item.text);
            }), (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
              "class": "picker-item picker-item-empty"
            }, "\xA0"), (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
              "class": "picker-item picker-item-empty"
            }, "\xA0"), (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
              "class": "picker-item picker-item-empty"
            }, "\xA0"));
          }
        }, {
          key: "el",
          get: function get() {
            return (0, _index_06cd27b1_js__WEBPACK_IMPORTED_MODULE_0__.i)(this);
          }
        }], [{
          key: "watchers",
          get: function get() {
            return {
              "value": ["valueChange"]
            };
          }
        }]);

        return PickerColumnInternal;
      }();

      var PICKER_COL_ACTIVE = 'picker-item-active';
      PickerColumnInternal.style = {
        ios: pickerColumnInternalIosCss,
        md: pickerColumnInternalMdCss
      };
      /***/
    }
  }]);
})();
//# sourceMappingURL=node_modules_ionic_core_dist_esm_ion-picker-column-internal_entry_js-es5.js.map